[
    {
        "code": "private int currentDepth(){\n  try {\n    Integer oneBased=((Integer)DEPTH_FIELD.get(this));\n    return oneBased - 1;\n  }\n catch (  IllegalAccessException e) {\n    throw new AssertionError(e);\n  }\n}\n",
        "text": " Returns a 0-based depth within the object graph of the current object being serialized.",
        "id": 1
    },
    {
        "code": "protected boolean[] datasetIntegrity(boolean nominalPredictor,boolean numericPredictor,boolean stringPredictor,boolean datePredictor,boolean relationalPredictor,boolean multiInstance,int classType,boolean predictorMissing,boolean classMissing){\n  print(\"kernel doesn't alter original datasets\");\n  printAttributeSummary(nominalPredictor,numericPredictor,stringPredictor,datePredictor,relationalPredictor,multiInstance,classType);\n  print(\"...\");\n  int numTrain=getNumInstances(), numClasses=2, missingLevel=20;\n  boolean[] result=new boolean[2];\n  Instances train=null;\n  Kernel kernel=null;\n  try {\n    train=makeTestDataset(42,numTrain,nominalPredictor ? getNumNominal() : 0,numericPredictor ? getNumNumeric() : 0,stringPredictor ? getNumString() : 0,datePredictor ? getNumDate() : 0,relationalPredictor ? getNumRelational() : 0,numClasses,classType,multiInstance);\n    if (missingLevel > 0) {\n      addMissing(train,missingLevel,predictorMissing,classMissing);\n    }\n    kernel=Kernel.makeCopies(getKernel(),1)[0];\n  }\n catch (  Exception ex) {\n    throw new Error(\"Error setting up for tests: \" + ex.getMessage());\n  }\n  try {\n    Instances trainCopy=new Instances(train);\n    kernel.buildKernel(trainCopy);\n    compareDatasets(train,trainCopy);\n    println(\"yes\");\n    result[0]=true;\n  }\n catch (  Exception ex) {\n    println(\"no\");\n    result[0]=false;\n    if (m_Debug) {\n      println(\"\\n=== Full Report ===\");\n      print(\"Problem during building\");\n      println(\": \" + ex.getMessage() + \"\\n\");\n      println(\"Here is the dataset:\\n\");\n      println(\"=== Train Dataset ===\\n\" + train.toString() + \"\\n\");\n    }\n  }\n  return result;\n}\n",
        "text": " Checks whether the scheme alters the training dataset during building. If the scheme needs to modify the data it should take a copy of the training data. Currently checks for changes to header structure, number of instances, order of instances, instance weights.",
        "id": 2
    },
    {
        "code": "public static int unionSize(long[] x,long[] y){\n  final int lx=x.length, ly=y.length;\n  final int min=(lx < ly) ? lx : ly;\n  int i=0, res=0;\n  for (; i < min; i++) {\n    res+=Long.bitCount(x[i] | y[i]);\n  }\n  for (; i < lx; i++) {\n    res+=Long.bitCount(x[i]);\n  }\n  for (; i < ly; i++) {\n    res+=Long.bitCount(y[i]);\n  }\n  return res;\n}\n",
        "text": " Compute the union size of two Bitsets.",
        "id": 3
    },
    {
        "code": "public void testReverseOrder4() throws Exception {\n  UUID id=UUID.randomUUID();\n  GridCacheAdapter<String,String> cache=grid.internalCache();\n  GridCacheContext<String,String> ctx=cache.context();\n  GridCacheTestEntryEx entry1=new GridCacheTestEntryEx(ctx,\"1\");\n  GridCacheTestEntryEx entry2=new GridCacheTestEntryEx(ctx,\"2\");\n  GridCacheVersion ver1=version(1);\n  GridCacheVersion ver2=version(2);\n  GridCacheVersion ver3=version(3);\n  GridCacheMvccCandidate v3k1=entry1.addLocal(3,ver3,0,true,false);\n  GridCacheMvccCandidate v3k2=entry2.addLocal(3,ver3,0,true,false);\n  linkCandidates(ctx,v3k1,v3k2);\n  entry1.readyLocal(ver3);\n  checkLocal(v3k1,ver3,true,true,false);\n  checkLocal(v3k2,ver3,false,false,false);\n  GridCacheMvccCandidate v1k1=entry1.addLocal(4,ver1,0,true,true);\n  GridCacheMvccCandidate v1k2=entry2.addLocal(4,ver1,0,true,true);\n  linkCandidates(ctx,v1k1,v1k2);\n  entry1.readyLocal(ver1);\n  entry2.readyLocal(ver1);\n  checkLocal(v3k1,ver3,true,true,false);\n  checkLocal(v3k2,ver3,false,false,false);\n  checkLocal(v1k1,ver1,true,false,false);\n  checkLocal(v1k2,ver1,true,false,false);\n  GridCacheMvccCandidate v2k2=entry2.addRemote(id,5,ver2,0,false,false);\n  checkRemote(v2k2,ver2,false,false);\n  entry2.readyLocal(v3k2);\n  checkLocal(v3k1,ver3,true,true,false);\n  checkLocal(v3k2,ver3,true,true,false);\n}\n",
        "text": " Tests local candidates with remote version in the middle on key2.",
        "id": 4
    },
    {
        "code": "@Override public void closingOK(){\n  List<AddUserFields.AttributeSpec> specs=new ArrayList<AddUserFields.AttributeSpec>();\n  for (int i=0; i < m_listModel.size(); i++) {\n    AddUserFields.AttributeSpec a=(AddUserFields.AttributeSpec)m_listModel.elementAt(i);\n    specs.add(a);\n  }\n  if (m_modifyL != null) {\n    m_modifyL.setModifiedStatus(AddUserFieldsCustomizer.this,true);\n  }\n  m_filter.setAttributeSpecs(specs);\n}\n",
        "text": " Actions to perform when the user has closed the dialog with the OK button.",
        "id": 5
    },
    {
        "code": "public String toString(){\n  StringBuffer text=new StringBuffer();\n  if ((m_classAttribute == null)) {\n    return \"SMO: No model built yet.\";\n  }\n  try {\n    text.append(\"SMO\\n\\n\");\n    text.append(\"Kernel used:\\n  \" + m_kernel.toString() + \"\\n\\n\");\n    for (int i=0; i < m_classAttribute.numValues(); i++) {\n      for (int j=i + 1; j < m_classAttribute.numValues(); j++) {\n        text.append(\"Classifier for classes: \" + m_classAttribute.value(i) + \", \"+ m_classAttribute.value(j)+ \"\\n\\n\");\n        text.append(m_classifiers[i][j]);\n        if (m_fitLogisticModels) {\n          text.append(\"\\n\\n\");\n          if (m_classifiers[i][j].m_logistic == null) {\n            text.append(\"No logistic model has been fit.\\n\");\n          }\n else {\n            text.append(m_classifiers[i][j].m_logistic);\n          }\n        }\n        text.append(\"\\n\\n\");\n      }\n    }\n  }\n catch (  Exception e) {\n    return \"Can't print SMO classifier.\";\n  }\n  return text.toString();\n}\n",
        "text": " Prints out the classifier.",
        "id": 6
    },
    {
        "code": "public final Sector union(Sector that){\n  if (that == null)   return this;\n  Angle minLat=this.minLatitude;\n  Angle maxLat=this.maxLatitude;\n  Angle minLon=this.minLongitude;\n  Angle maxLon=this.maxLongitude;\n  if (that.minLatitude.degrees < this.minLatitude.degrees)   minLat=that.minLatitude;\n  if (that.maxLatitude.degrees > this.maxLatitude.degrees)   maxLat=that.maxLatitude;\n  if (that.minLongitude.degrees < this.minLongitude.degrees)   minLon=that.minLongitude;\n  if (that.maxLongitude.degrees > this.maxLongitude.degrees)   maxLon=that.maxLongitude;\n  return new Sector(minLat,maxLat,minLon,maxLon);\n}\n",
        "text": " Returns a new sector whose angles are the extremes of the this sector and another. The new sector's minimum latitude and longitude will be the minimum of the two sectors. The new sector's maximum latitude and longitude will be the maximum of the two sectors. The sectors are assumed to be normalized to +/- 90 degrees latitude and +/- 180 degrees longitude. The result of the operation is undefined if they are not.",
        "id": 7
    },
    {
        "code": "private static boolean isDoubleEqual(double value,double valueToCompare){\n  return (Math.abs(value - valueToCompare) < 0.001);\n}\n",
        "text": " Checks if is double values are equal.",
        "id": 8
    },
    {
        "code": "public void testIntValuePos(){\n  String a=\"123809648392384754573567356745735.63567890295784902768787678287E+21\";\n  BigDecimal aNumber=new BigDecimal(a);\n  int result=-218520473;\n  assertTrue(\"incorrect value\",aNumber.intValue() == result);\n}\n",
        "text": " Integer value of a positive BigDecimal",
        "id": 9
    },
    {
        "code": "private void walk(File directory,int depth,Collection<T> results) throws IOException {\n  checkIfCancelled(directory,depth,results);\n  if (handleDirectory(directory,depth,results)) {\n    handleDirectoryStart(directory,depth,results);\n    int childDepth=depth + 1;\n    if (depthLimit < 0 || childDepth <= depthLimit) {\n      checkIfCancelled(directory,depth,results);\n      File[] childFiles=filter == null ? directory.listFiles() : directory.listFiles(filter);\n      childFiles=filterDirectoryContents(directory,depth,childFiles);\n      if (childFiles == null) {\n        handleRestricted(directory,childDepth,results);\n      }\n else {\n        for (        File childFile : childFiles) {\n          if (childFile.isDirectory()) {\n            walk(childFile,childDepth,results);\n          }\n else {\n            checkIfCancelled(childFile,childDepth,results);\n            handleFile(childFile,childDepth,results);\n            checkIfCancelled(childFile,childDepth,results);\n          }\n        }\n      }\n    }\n    handleDirectoryEnd(directory,depth,results);\n  }\n  checkIfCancelled(directory,depth,results);\n}\n",
        "text": " Main recursive method to examine the directory hierarchy.",
        "id": 10
    },
    {
        "code": "public static Object[] ordinalArray(TupleSet tuples,String field){\n  return ordinalArray(tuples,field,DefaultLiteralComparator.getInstance());\n}\n",
        "text": " Get a sorted array containing all column values for a given tuple iterator and field.",
        "id": 11
    },
    {
        "code": "public void testDivideExceptionInvalidRM(){\n  String a=\"1231212478987482988429808779810457634781384756794987\";\n  int aScale=15;\n  String b=\"747233429293018787918347987234564568\";\n  int bScale=10;\n  BigDecimal aNumber=new BigDecimal(new BigInteger(a),aScale);\n  BigDecimal bNumber=new BigDecimal(new BigInteger(b),bScale);\n  try {\n    aNumber.divide(bNumber,100);\n    fail(\"IllegalArgumentException has not been caught\");\n  }\n catch (  IllegalArgumentException e) {\n    assertEquals(\"Improper exception message\",\"Invalid rounding mode\",e.getMessage());\n  }\n}\n",
        "text": " Divide with invalid rounding mode",
        "id": 12
    },
    {
        "code": "@Override public void datasetChanged(DatasetChangeEvent event){\n  super.datasetChanged(event);\n  if (this.subplots == null) {\n    return;\n  }\n  XYDataset dataset=null;\n  if (event.getDataset() instanceof XYDataset) {\n    dataset=(XYDataset)event.getDataset();\n  }\n  for (  XYPlot subplot : this.subplots) {\n    if (subplot.indexOf(dataset) >= 0) {\n      subplot.configureRangeAxes();\n    }\n  }\n}\n",
        "text": " Receives notification of a change to the plot's dataset.   The axis ranges are updated if necessary.",
        "id": 13
    },
    {
        "code": "public boolean onScheduleAsLibrary(Config config,Config runtime,IScheduler scheduler,PackingPlan packing){\n  boolean ret=false;\n  try {\n    scheduler.initialize(config,runtime);\n    ret=scheduler.onSchedule(packing);\n    if (ret) {\n      ret=SchedulerUtils.setLibSchedulerLocation(runtime,scheduler,false);\n    }\n else {\n      LOG.severe(\"Failed to invoke IScheduler as library\");\n    }\n  }\n  finally {\n    scheduler.close();\n  }\n  return ret;\n}\n",
        "text": " Invoke the onScheduler() in IScheduler directly as a library",
        "id": 14
    },
    {
        "code": "public static boolean isStringType(Type t){\n  return t.equals(RefType.v(\"java.lang.String\"));\n}\n",
        "text": " Returns true if specified type is Java.lang.String ",
        "id": 15
    },
    {
        "code": "public Entry updateOrCreateSource(User user,String id,String url,String title,Long modTime,Long createTime,boolean isAdmin,Errors errors){\n  if (user == null) {\n    Errors.add(errors,errorMessages.errorUserIsNull());\n    return null;\n  }\n  if (url == null) {\n    Errors.add(errors,errorMessages.errorUrlIsNull());\n    return null;\n  }\n  Entry source=getEntryByUserIdAndUrl(user.getId(),url);\n  if (source == null) {\n    if (url.isEmpty()) {\n      Errors.add(errors,errorMessages.errorUrlIsEmpty());\n      return null;\n    }\n    if (title == null) {\n      Errors.add(errors,errorMessages.errorTitleIsNull());\n      return null;\n    }\n    if (title.isEmpty()) {\n      Errors.add(errors,errorMessages.errorTitleIsEmpty());\n      return null;\n    }\n    if (modTime == null) {\n      Errors.add(errors,errorMessages.errorModTimeIsNull());\n      return null;\n    }\n    if (createTime == null) {\n      Errors.add(errors,errorMessages.errorCreateTimeIsNull());\n      return null;\n    }\n    if (id != null && !idGenerator.isIdWellFormed(id)) {\n      Errors.add(errors,errorMessages.errorIdIsInvalid());\n      return null;\n    }\n    if (createTime.longValue() > modTime.longValue()) {\n      modTime=createTime;\n    }\n    if (url != null) {\n      url=cleanUpText(url);\n    }\n    if (title != null) {\n      title=cleanUpText(title);\n    }\n    source=new Entry();\n    source.setDb(db);\n    if (id == null) {\n      id=idGenerator.getAnotherId();\n    }\n    source.setId(id);\n    source.setSourceUrl(url);\n    source.setSourceTitle(title);\n    source.setCreateTime(createTime);\n    source.setType(Constants.source);\n    source.setUserId(user.getId());\n    db.persistEntry(source);\n  }\n else   if (!canUserModifyEntry(user,source,isAdmin)) {\n    Errors.add(errors,errorMessages.errorUserIsNotEntitledToModifyTheSource());\n    return null;\n  }\n  source.setModTime(modTime);\n  return source;\n}\n",
        "text": " API method. Returns an entry for the source indexed by the user and the url. This method creates it if it didn't already exist.",
        "id": 16
    },
    {
        "code": "private void validateSqlStatement(String sql,int jdbcStatementIndex){\n  Assert.isTrue(StringUtils.isNotBlank(sql),\"JDBC statement [\" + jdbcStatementIndex + \"] SQL is required\");\n}\n",
        "text": " Validates the given SQL statement where its position in the list of statement is the given index. This method does not validate SQL syntax.",
        "id": 17
    },
    {
        "code": "public static Long[] valuesOf(long[] array){\n  Long[] dest=new Long[array.length];\n  for (int i=0; i < array.length; i++) {\n    dest[i]=Long.valueOf(array[i]);\n  }\n  return dest;\n}\n",
        "text": " Converts to object array.",
        "id": 18
    },
    {
        "code": "@Override public boolean isTraceEnabled(){\n  return logger.isLoggable(Level.FINEST);\n}\n",
        "text": " Is this logger instance enabled for the FINEST level?",
        "id": 19
    },
    {
        "code": "private static void useMissile(Player player){\n  StackableItem projectilesItem=null;\n  if (player.getRangeWeapon() != null) {\n    projectilesItem=player.getAmmunition();\n  }\n  if (projectilesItem == null) {\n    projectilesItem=player.getMissileIfNotHoldingOtherWeapon();\n  }\n  if (projectilesItem != null) {\n    projectilesItem.removeOne();\n  }\n}\n",
        "text": " Remove an used up missile from an attacking player.",
        "id": 20
    },
    {
        "code": "public TcpMatcher(final NetworkConfig config){\n  super(config);\n}\n",
        "text": " Creates a new matcher for running CoAP over TCP.",
        "id": 21
    },
    {
        "code": "private int determineMaxLevelRec(int level,Node v){\n  int newLevel=level;\n  for (Edge e=v.getFirstOutEdge(); e != null; e=v.getNextOutEdge(e)) {\n    newLevel=Math.max(newLevel,determineMaxLevelRec(level,e.getTarget()) + 1);\n  }\n  return newLevel;\n}\n",
        "text": " recursively does the work",
        "id": 22
    },
    {
        "code": "protected void requestPassCodeConfirmation(){\n  clearBoxes();\n  mPassCodeHdr.setText(R.string.pass_code_reenter_your_pass_code);\n  mPassCodeHdrExplanation.setVisibility(View.INVISIBLE);\n  mConfirmingPassCode=true;\n}\n",
        "text": " Ask to the user for retyping the pass code just entered before saving it as the current pass code.",
        "id": 23
    },
    {
        "code": "private void addWorkerFailed(Worker w){\n  final ReentrantLock mainLock=this.mainLock;\n  mainLock.lock();\n  try {\n    if (w != null)     workers.remove(w);\n    decrementWorkerCount();\n    tryTerminate();\n  }\n  finally {\n    mainLock.unlock();\n  }\n}\n",
        "text": " Rolls back the worker thread creation. - removes worker from workers, if present - decrements worker count - rechecks for termination, in case the existence of this worker was holding up termination",
        "id": 24
    },
    {
        "code": "public void testInsert4() throws SQLException {\n  DatabaseCreator.fillSimpleTable1(conn);\n  statement.execute(\"INSERT INTO \" + DatabaseCreator.SIMPLE_TABLE2 + \" SELECT id, speed*10 AS speed, size-1 AS size FROM \"+ DatabaseCreator.SIMPLE_TABLE1);\n  ResultSet r=statement.executeQuery(\"SELECT COUNT(*) FROM \" + DatabaseCreator.SIMPLE_TABLE2 + \" AS a JOIN \"+ DatabaseCreator.SIMPLE_TABLE1+ \" AS b ON a.speed = 10*b.speed AND a.size = b.size-1\");\n  r.next();\n  assertEquals(\"Should be 2 rows\",2,r.getInt(1));\n  r.close();\n}\n",
        "text": " InsertFunctionalityTest#testInsert4(). Tests INSERT ... SELECT with expressions in SELECT query",
        "id": 25
    },
    {
        "code": "private synchronized void putMapEntry(String localId,MapEntry entry){\n  if (!isLocalId(localId)) {\n    throw new IllegalStateException(\"Tried to get invalid local id: \\\"\" + localId + \"\\\".\");\n  }\n  JSONObject json=new JSONObject();\n  try {\n    json.put(\"retainCount\",entry.retainCount);\n    if (entry.objectId != null) {\n      json.put(\"objectId\",entry.objectId);\n    }\n  }\n catch (  JSONException je) {\n    throw new IllegalStateException(\"Error creating local id map entry.\",je);\n  }\n  File file=new File(diskPath,localId);\n  if (!diskPath.exists()) {\n    diskPath.mkdirs();\n  }\n  try {\n    ParseFileUtils.writeJSONObjectToFile(file,json);\n  }\n catch (  IOException e) {\n  }\n}\n",
        "text": " Writes one entry to the local id map on disk.",
        "id": 26
    },
    {
        "code": "public void endElement(String namespaceURI,String localName,String name) throws org.xml.sax.SAXException {\n  if (m_inEntityRef)   return;\n  m_prefixMap.popNamespaces(m_elemContext.m_currentElemDepth,null);\n  try {\n    final java.io.Writer writer=m_writer;\n    if (m_elemContext.m_startTagOpen) {\n      if (m_tracer != null)       super.fireStartElem(m_elemContext.m_elementName);\n      int nAttrs=m_attributes.getLength();\n      if (nAttrs > 0) {\n        processAttributes(m_writer,nAttrs);\n        m_attributes.clear();\n      }\n      if (m_spaceBeforeClose)       writer.write(\" />\");\n else       writer.write(\"/>\");\n    }\n else {\n      if (m_cdataTagOpen)       closeCDATA();\n      if (shouldIndent())       indent(m_elemContext.m_currentElemDepth - 1);\n      writer.write('<');\n      writer.write('/');\n      writer.write(name);\n      writer.write('>');\n    }\n  }\n catch (  IOException e) {\n    throw new SAXException(e);\n  }\n  if (!m_elemContext.m_startTagOpen && m_doIndent) {\n    m_ispreserve=m_preserves.isEmpty() ? false : m_preserves.pop();\n  }\n  m_isprevtext=false;\n  if (m_tracer != null)   super.fireEndElem(name);\n  m_elemContext=m_elemContext.m_prev;\n}\n",
        "text": " Receive notification of the end of an element.",
        "id": 27
    },
    {
        "code": "public static void f(String msg,Object... args){\n  if (!allowWtf)   return;\n  StackTraceElement caller=getCallerStackTraceElement();\n  String tag=generateTag(caller);\n  if (sLevel > LEVEL_FATAL) {\n    return;\n  }\n  if (args.length > 0) {\n    msg=String.format(msg,args);\n  }\n  Log.wtf(tag,msg);\n}\n",
        "text": " Send a FATAL ERROR log message",
        "id": 28
    },
    {
        "code": "public void deleteLeaves(String name){\n  for (int i=0; i < _leaves.size(); i++) {\n    CatalogTreeLeaf leaf=_leaves.get(i);\n    if (name.equals(leaf.getName())) {\n      _leaves.remove(i);\n    }\n  }\n}\n",
        "text": " Leaves can be used for many-to-many relations",
        "id": 29
    },
    {
        "code": "public String toString(){\n  final StringBuffer s=new StringBuffer();\n  final int size=size();\n  for (int i=0; i < size; i++)   s.append(getInt(i));\n  return s.toString();\n}\n",
        "text": " Returns a string representation of this vector.  Note that this string representation shows the bit of index 0 at the leftmost position.",
        "id": 30
    },
    {
        "code": "protected boolean validate(final char[] component,final int soffset,int eoffset,final BitSet generous){\n  if (eoffset == -1) {\n    eoffset=component.length - 1;\n  }\n  for (int i=soffset; i <= eoffset; i++) {\n    if (!generous.get(component[i])) {\n      return false;\n    }\n  }\n  return true;\n}\n",
        "text": " Validate the URI characters within a specific component. The component must be performed after escape encoding. Or it doesn't include escaped characters.   It's not that much strict, generous. The strict validation might be performed before being called this method.",
        "id": 31
    },
    {
        "code": "private void buildPieces(){\n  pieces=new Piece[pathArray.size()];\n  Paint paint=new Paint();\n  Matrix matrix=new Matrix();\n  Canvas canvas=new Canvas();\n  for (int i=0; i < pieces.length; i++) {\n    int shadow=Utils.nextInt(Utils.dp2px(2),Utils.dp2px(9));\n    Path path=pathArray.get(i);\n    RectF r=new RectF();\n    path.computeBounds(r,true);\n    Bitmap pBitmap=Utils.createBitmapSafely((int)r.width() + shadow * 2,(int)r.height() + shadow * 2,Bitmap.Config.ARGB_4444,1);\n    if (pBitmap == null) {\n      pieces[i]=new Piece(-1,-1,null,shadow);\n      continue;\n    }\n    pieces[i]=new Piece((int)r.left + mTouchPoint.x - shadow,(int)r.top + mTouchPoint.y - shadow,pBitmap,shadow);\n    canvas.setBitmap(pieces[i].bitmap);\n    BitmapShader mBitmapShader=new BitmapShader(mBitmap,Shader.TileMode.CLAMP,Shader.TileMode.CLAMP);\n    matrix.reset();\n    matrix.setTranslate(-r.left - offsetX + shadow,-r.top - offsetY + shadow);\n    mBitmapShader.setLocalMatrix(matrix);\n    paint.reset();\n    Path offsetPath=new Path();\n    offsetPath.addPath(path,-r.left + shadow,-r.top + shadow);\n    paint.setStyle(Paint.Style.FILL);\n    paint.setShadowLayer(shadow,0,0,0xff333333);\n    canvas.drawPath(offsetPath,paint);\n    paint.setShadowLayer(0,0,0,0);\n    paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.XOR));\n    canvas.drawPath(offsetPath,paint);\n    paint.setXfermode(null);\n    paint.setShader(mBitmapShader);\n    paint.setAlpha(0xcc);\n    canvas.drawPath(offsetPath,paint);\n  }\n  Arrays.sort(pieces);\n}\n",
        "text": " Build the final bitmap-pieces to draw in animation",
        "id": 32
    },
    {
        "code": "public boolean removeShutdownHook(Thread hook){\n  SecurityManager sm=System.getSecurityManager();\n  if (sm != null) {\n    sm.checkPermission(RuntimePermissionCollection.SHUTDOWN_HOOKS_PERMISSION);\n  }\n  if (hook == null)   throw new NullPointerException(\"null is not allowed here\");\n  if (VMState > 0) {\n    throw new IllegalStateException();\n  }\nsynchronized (hooksList) {\n    return hooksList.remove(hook);\n  }\n}\n",
        "text": " De-registers a previously-registered virtual-machine shutdown hook.",
        "id": 33
    },
    {
        "code": "public void run(){\n  while (m_keyboardStream != null) {\n    try {\n      if (m_keyboardReadRequest) {\n        String s=m_keyboardStream.readLine();\n        m_keyboardInput.add(s);\n        m_keyboardReadRequest=false;\nsynchronized (this) {\n          notifyAll();\n        }\n      }\n else       try {\n        Thread.sleep(50);\n      }\n catch (      InterruptedException ie) {\n      }\n    }\n catch (    IOException io) {\n    }\n  }\n}\n",
        "text": " A separate thread collects our input so that we can block in the doContinue on the main thread and then allow the user to interrupt us via keyboard input on this thread.   We built the stupid thing in this manner, since readLine() will block no matter what and if we quit we can't seem to kill this thread.  .close() doesn't work and Thread.stop(), etc. all fail to do the job.   Thus we needed to take a request response approach so that we only block when requested to do so.",
        "id": 34
    },
    {
        "code": "public boolean boundScroll(){\n  float curScroll=getStackScroll();\n  float newScroll=getBoundedStackScroll(curScroll);\n  if (Float.compare(newScroll,curScroll) != 0) {\n    setStackScroll(newScroll);\n    return true;\n  }\n  return false;\n}\n",
        "text": " Bounds the current scroll if necessary",
        "id": 35
    },
    {
        "code": "@Override public AggregateableEvaluation aggregate(Evaluation evaluation){\n  m_Incorrect+=evaluation.incorrect();\n  m_Correct+=evaluation.correct();\n  m_Unclassified+=evaluation.unclassified();\n  m_MissingClass+=evaluation.m_MissingClass;\n  m_WithClass+=evaluation.m_WithClass;\n  if (evaluation.m_ConfusionMatrix != null) {\n    double[][] newMatrix=evaluation.confusionMatrix();\n    if (newMatrix != null) {\n      for (int i=0; i < m_ConfusionMatrix.length; i++) {\n        for (int j=0; j < m_ConfusionMatrix[i].length; j++) {\n          m_ConfusionMatrix[i][j]+=newMatrix[i][j];\n        }\n      }\n    }\n  }\n  double[] newClassPriors=evaluation.m_ClassPriors;\n  if (newClassPriors != null && m_ClassPriors != null) {\n    for (int i=0; i < this.m_ClassPriors.length; i++) {\n      m_ClassPriors[i]=newClassPriors[i];\n    }\n  }\n  m_ClassPriorsSum=evaluation.m_ClassPriorsSum;\n  m_TotalCost+=evaluation.totalCost();\n  m_SumErr+=evaluation.m_SumErr;\n  m_SumAbsErr+=evaluation.m_SumAbsErr;\n  m_SumSqrErr+=evaluation.m_SumSqrErr;\n  m_SumClass+=evaluation.m_SumClass;\n  m_SumSqrClass+=evaluation.m_SumSqrClass;\n  m_SumPredicted+=evaluation.m_SumPredicted;\n  m_SumSqrPredicted+=evaluation.m_SumSqrPredicted;\n  m_SumClassPredicted+=evaluation.m_SumClassPredicted;\n  m_SumPriorAbsErr+=evaluation.m_SumPriorAbsErr;\n  m_SumPriorSqrErr+=evaluation.m_SumPriorSqrErr;\n  m_SumKBInfo+=evaluation.m_SumKBInfo;\n  double[] newMarginCounts=evaluation.m_MarginCounts;\n  if (newMarginCounts != null) {\n    for (int i=0; i < m_MarginCounts.length; i++) {\n      m_MarginCounts[i]+=newMarginCounts[i];\n    }\n  }\n  m_ComplexityStatisticsAvailable=evaluation.m_ComplexityStatisticsAvailable;\n  m_CoverageStatisticsAvailable=evaluation.m_CoverageStatisticsAvailable;\n  m_SumPriorEntropy+=evaluation.m_SumPriorEntropy;\n  m_SumSchemeEntropy+=evaluation.m_SumSchemeEntropy;\n  m_TotalSizeOfRegions+=evaluation.m_TotalSizeOfRegions;\n  m_TotalCoverage+=evaluation.m_TotalCoverage;\n  ArrayList<Prediction> predsToAdd=evaluation.m_Predictions;\n  if (predsToAdd != null) {\n    if (m_Predictions == null) {\n      m_Predictions=new ArrayList<Prediction>();\n    }\n    for (int i=0; i < predsToAdd.size(); i++) {\n      m_Predictions.add(predsToAdd.get(i));\n    }\n  }\n  return this;\n}\n",
        "text": " Adds the statistics encapsulated in the supplied Evaluation object into this one. Does not perform any checks for compatibility between the supplied Evaluation object and this one.",
        "id": 36
    },
    {
        "code": "public void waitForVolumesToBeVisible(CGRequestParams request){\n  scan(request.getCopies(),request.getRsets());\n}\n",
        "text": " scans all sites until all volumes involved in the Recoverpoint protection are visible",
        "id": 37
    },
    {
        "code": "protected void startAdditionalServices(final Cache cache,final Map<String,Object> options) throws Exception {\n}\n",
        "text": " This method is called immediately following cache creation in the spawned process, but prior to setting the RUNNING flag in the status file. So the spawning process will block until this method completes.",
        "id": 38
    },
    {
        "code": "public void updateView(){\n  if (fInputElement != null && fParentComposite != null) {\n    IndicatorViewState oldState=fStateMap.get(fInputElement);\n    boolean reload=fFilesToReoad.contains(fInputElement);\n    if (reload || oldState == null) {\n      JsonObject jsonObject=DroidsafePluginUtilities.parseIndicatorFile(fInputElement);\n      if (jsonObject == null)       return;\n      fFilesToReoad.remove(fInputElement);\n      fState=new IndicatorViewState(fInputElement,jsonObject,getSecuritySpec(),oldState);\n      fStateMap.put(fInputElement,fState);\n    }\n else {\n      fState=oldState;\n    }\n    setPartName(fState.indicatorType);\n    showPage(PAGE_VIEWER);\n    fTreeViewer.setInput(fState.jsonObject);\n    if (fTreeViewer.getSorter() == null)     sortByField(getSortByField());\n  }\n else {\n    setPartName(DEFAULT_PART_NAME);\n  }\n}\n",
        "text": " Update the content of the outline view.",
        "id": 39
    },
    {
        "code": "@Override public void paint(Graphics g){\n  g.drawImage(image,0,0,this);\n  if (!paintCalled) {\n    paintCalled=true;\nsynchronized (this) {\n      notifyAll();\n    }\n  }\n}\n",
        "text": " Paints the image on the window.",
        "id": 40
    },
    {
        "code": "@Override public boolean connectionAllowed(String eventName){\n  if (m_listenees.containsKey(eventName)) {\n    return false;\n  }\n  return true;\n}\n",
        "text": " Returns true if, at this time, the object will accept a connection with respect to the named event",
        "id": 41
    },
    {
        "code": "public boolean isPrefixed(){\n  return name.indexOf(':') >= 0;\n}\n",
        "text": " It returns true if the attribute is prefixed (used the : character).",
        "id": 42
    },
    {
        "code": "public void releaseAnyConnection(Connection connection) throws SQLException {\n  try {\n    connection.close();\n  }\n catch (  Exception ex) {\n    throw new RuntimeException(ex);\n  }\n}\n",
        "text": " Release a non-shard-specific connection.",
        "id": 43
    },
    {
        "code": "public QuickActionView addActions(Collection<Action> actions){\n  checkShown();\n  mActions.addAll(actions);\n  return this;\n}\n",
        "text": " Adds a collection of actions to the QuickActionView",
        "id": 44
    },
    {
        "code": "public void addSeriesRenderer(int index,SimpleSeriesRenderer renderer){\n  mRenderers.add(index,renderer);\n}\n",
        "text": " Adds a simple renderer to the multiple renderer.",
        "id": 45
    },
    {
        "code": "public static boolean copyStream(InputStream is,OutputStream os,CopyListener listener,int bufferSize) throws IOException {\n  int current=0;\n  int total=is.available();\n  if (total <= 0) {\n    total=DEFAULT_IMAGE_TOTAL_SIZE;\n  }\n  final byte[] bytes=new byte[bufferSize];\n  int count;\n  if (shouldStopLoading(listener,current,total))   return false;\n  while ((count=is.read(bytes,0,bufferSize)) != -1) {\n    os.write(bytes,0,count);\n    current+=count;\n    if (shouldStopLoading(listener,current,total))     return false;\n  }\n  os.flush();\n  return true;\n}\n",
        "text": " Copies stream, fires progress events by listener, can be interrupted by listener.",
        "id": 46
    },
    {
        "code": "private float calcAngle(float value){\n  return value / mData.getYValueSum() * 360f;\n}\n",
        "text": " calculates the needed angle for a given value",
        "id": 47
    },
    {
        "code": "public synchronized void returnBuf(byte[] buf){\n  if (buf == null || buf.length > mSizeLimit) {\n    return;\n  }\n  mBuffersByLastUse.add(buf);\n  int pos=Collections.binarySearch(mBuffersBySize,buf,BUF_COMPARATOR);\n  if (pos < 0) {\n    pos=-pos - 1;\n  }\n  mBuffersBySize.add(pos,buf);\n  mCurrentSize+=buf.length;\n  trim();\n}\n",
        "text": " Returns a buffer to the pool, throwing away old buffers if the pool would exceed its allotted size.",
        "id": 48
    },
    {
        "code": "protected <T extends AbstractOptionValue<?,?>>AbstractOptions(Function<T,T> valueFilter,AbstractOptions baseOptions,Iterable<T> values){\n  requireNonNull(baseOptions,\"baseOptions\");\n  requireNonNull(valueFilter,\"valueFilter\");\n  requireNonNull(values,\"values\");\n  valueMap=new IdentityHashMap<>(baseOptions.valueMap);\n  putAll(valueFilter,StreamSupport.stream(values.spliterator(),false));\n}\n",
        "text": " Creates a new instance.",
        "id": 49
    },
    {
        "code": "public CharSeq concat(CharSeq another){\n  return new CharSeq(str + another.str);\n}\n",
        "text": " Append string of the given CharSeq to this CharSeq",
        "id": 50
    },
    {
        "code": "@Override protected void doGet(HttpServletRequest req,HttpServletResponse resp) throws ServletException, IOException {\n  resp.setContentType(\"text/plain\");\n  PrintWriter sendToClient=resp.getWriter();\n  for (  Video v : this.videos) {\n    sendToClient.write(v.getName() + \" : \" + v.getUrl()+ \"\\n\");\n  }\n}\n",
        "text": " This method processes all of the HTTP GET requests routed to the servlet by the web container. This method loops through the lists of videos that have been sent to it and generates a plain/text  list of the videos that is sent back to the client.",
        "id": 51
    },
    {
        "code": "protected void notifyStateChange(int oldState,int newState){\n  mState=newState;\n  if (oldState != newState) {\n    firePropertyChange(\"KnownState\",Integer.valueOf(oldState),Integer.valueOf(newState));\n  }\n}\n",
        "text": " Change the stored state value and do notification, but don't change anything in the hardware",
        "id": 52
    },
    {
        "code": "public void test_GetOrder(){\n  assertEquals(\"wrong order was reteurned\",BigInteger.valueOf(1),ecps.getOrder());\n}\n",
        "text": " test for getOrder() method",
        "id": 53
    },
    {
        "code": "private void formatAndLogThrowable(LoggingLevel level,Color color,String msg,Throwable t){\n  if (!USE_COLORS) {\n    formatAndLogThrowable(level,msg,t);\n    return;\n  }\n  if (PhotonLogger.level.id < level.id) {\n    return;\n  }\n  LocalDateTime dateTime=LocalDateTime.now();\n  String formatted=formatLogLine(level,dateTime,msg);\n  LoggingService.logThrowable(dateTime,t,formatted,color);\n}\n",
        "text": " Formats and logs a message with a Throwable.",
        "id": 54
    },
    {
        "code": "public static String constructQueueRedisKey(String queueName,String shardName,int priority,PinLaterJobState state){\n  return String.format(\"%s_%s_%s.p%1d_s%1d\",PINLATER_QUEUE_KEY_PREFIX,shardName,queueName,priority,state.getValue());\n}\n",
        "text": " Constructs the redis queue sorted set key name given a queue name, shard id and priority.",
        "id": 55
    },
    {
        "code": "public static String decodeCharset(String s,String charset){\n  if (s == null) {\n    return null;\n  }\n  try {\n    byte buf[]=s.getBytes(ASCII_CHARSET);\n    return (new String(buf,0,buf.length,charset));\n  }\n catch (  UnsupportedEncodingException uee) {\n    return s;\n  }\n}\n",
        "text": " Decodes the string into specified charset",
        "id": 56
    },
    {
        "code": "public void addRestrictedDomain(String domainName){\n  if (StringUtils.isEmpty(domainName)) {\n    return;\n  }\n  if (restrictedDomains == null) {\n    restrictedDomains=new ArrayList<>();\n  }\n  restrictedDomains.add(domainName);\n}\n",
        "text": " Adds specified domain name to the list of restricted domains",
        "id": 57
    },
    {
        "code": "StoppableReadLock(ReadWriteLock lock,CancelCriterion stopper){\n  this.lock=lock.readLock();\n  this.stopper=stopper;\n}\n",
        "text": " Create a new read lock from the given lock",
        "id": 58
    },
    {
        "code": "public void testisAutoIncrement(){\n  try {\n    assertFalse(rsmd.isAutoIncrement(1));\n  }\n catch (  SQLException e1) {\n    fail(\"ResultSetMetaDataTest.testGetScale()\" + e1.getMessage());\n    e1.printStackTrace();\n  }\n  try {\n    conn.close();\n    rsmd.getSchemaName(2);\n    fail(\"Exception expected\");\n  }\n catch (  SQLException e) {\n  }\n}\n",
        "text": " Tests fail: always returns false, failing statements commented out. Feature only partially implemented.Missing: Test positive case Not supported.",
        "id": 59
    },
    {
        "code": "private long computeInterfaceHash(){\n  long hash=0;\n  ByteArrayOutputStream sink=new ByteArrayOutputStream(512);\n  try {\n    MessageDigest md=MessageDigest.getInstance(\"SHA\");\n    DataOutputStream out=new DataOutputStream(new DigestOutputStream(sink,md));\n    out.writeInt(INTERFACE_HASH_STUB_VERSION);\n    for (    Method method : remoteMethods) {\n      MethodDoc methodDoc=method.methodDoc();\n      out.writeUTF(methodDoc.name());\n      out.writeUTF(Util.methodDescriptorOf(methodDoc));\n      ClassDoc exceptions[]=methodDoc.thrownExceptions();\n      Arrays.sort(exceptions,new ClassDocComparator());\n      for (      ClassDoc ex : exceptions) {\n        out.writeUTF(Util.binaryNameOf(ex));\n      }\n    }\n    out.flush();\n    byte hashArray[]=md.digest();\n    for (int i=0; i < Math.min(8,hashArray.length); i++) {\n      hash+=((long)(hashArray[i] & 0xFF)) << (i * 8);\n    }\n  }\n catch (  IOException e) {\n    throw new AssertionError(e);\n  }\ncatch (  NoSuchAlgorithmException e) {\n    throw new AssertionError(e);\n  }\n  return hash;\n}\n",
        "text": " Computes the interface hash of the stub/skeleton pair for this remote implementation class.  This is the 64-bit value used to enforce compatibility between a stub class and a skeleton class in the JDK 1.1 version of the JRMP stub/skeleton protocol. It is calculated using the first 64 bits of an SHA digest.  The digest is of a stream consisting of the following data: (int) stub version number, always 1 for each remote method, in order of operation number: (UTF-8) method name (UTF-8) method descriptor for each declared exception, in alphabetical name order: (UTF-8) name of exception class (where UTF-8 includes a 16-bit length prefix as written by java.io.DataOutput.writeUTF).",
        "id": 60
    },
    {
        "code": "public static void copy(byte[] in,OutputStream out) throws IOException {\n  Assert.notNull(in,\"No input byte array specified\");\n  Assert.notNull(out,\"No OutputStream specified\");\n  out.write(in);\n}\n",
        "text": " Copy the contents of the given byte array to the given OutputStream. Leaves the stream open when done.",
        "id": 61
    },
    {
        "code": "public boolean isEmpty(){\n  return items.isEmpty();\n}\n",
        "text": " Returns true whether this page doesn't contain items, returns false if it does. ",
        "id": 62
    },
    {
        "code": "private static native boolean renderFrame(int[] pixels,long gifFileInPtr,int[] metaData);\n",
        "text": " Decodes a frame if needed.",
        "id": 63
    },
    {
        "code": "private static int encodeText(CharSequence msg,int startpos,int count,StringBuilder sb,int initialSubmode){\n  StringBuilder tmp=new StringBuilder(count);\n  int submode=initialSubmode;\n  int idx=0;\n  while (true) {\n    char ch=msg.charAt(startpos + idx);\nswitch (submode) {\ncase SUBMODE_ALPHA:\n      if (isAlphaUpper(ch)) {\n        if (ch == ' ') {\n          tmp.append((char)26);\n        }\n else {\n          tmp.append((char)(ch - 65));\n        }\n      }\n else {\n        if (isAlphaLower(ch)) {\n          submode=SUBMODE_LOWER;\n          tmp.append((char)27);\n          continue;\n        }\n else         if (isMixed(ch)) {\n          submode=SUBMODE_MIXED;\n          tmp.append((char)28);\n          continue;\n        }\n else {\n          tmp.append((char)29);\n          tmp.append((char)PUNCTUATION[ch]);\n          break;\n        }\n      }\n    break;\ncase SUBMODE_LOWER:\n  if (isAlphaLower(ch)) {\n    if (ch == ' ') {\n      tmp.append((char)26);\n    }\n else {\n      tmp.append((char)(ch - 97));\n    }\n  }\n else {\n    if (isAlphaUpper(ch)) {\n      tmp.append((char)27);\n      tmp.append((char)(ch - 65));\n      break;\n    }\n else     if (isMixed(ch)) {\n      submode=SUBMODE_MIXED;\n      tmp.append((char)28);\n      continue;\n    }\n else {\n      tmp.append((char)29);\n      tmp.append((char)PUNCTUATION[ch]);\n      break;\n    }\n  }\nbreak;\ncase SUBMODE_MIXED:\nif (isMixed(ch)) {\ntmp.append((char)MIXED[ch]);\n}\n else {\nif (isAlphaUpper(ch)) {\n  submode=SUBMODE_ALPHA;\n  tmp.append((char)28);\n  continue;\n}\n else if (isAlphaLower(ch)) {\n  submode=SUBMODE_LOWER;\n  tmp.append((char)27);\n  continue;\n}\n else {\n  if (startpos + idx + 1 < count) {\n    char next=msg.charAt(startpos + idx + 1);\n    if (isPunctuation(next)) {\n      submode=SUBMODE_PUNCTUATION;\n      tmp.append((char)25);\n      continue;\n    }\n  }\n  tmp.append((char)29);\n  tmp.append((char)PUNCTUATION[ch]);\n}\n}\nbreak;\ndefault :\nif (isPunctuation(ch)) {\ntmp.append((char)PUNCTUATION[ch]);\n}\n else {\nsubmode=SUBMODE_ALPHA;\ntmp.append((char)29);\ncontinue;\n}\n}\nidx++;\nif (idx >= count) {\nbreak;\n}\n}\nchar h=0;\nint len=tmp.length();\nfor (int i=0; i < len; i++) {\nboolean odd=(i % 2) != 0;\nif (odd) {\nh=(char)((h * 30) + tmp.charAt(i));\nsb.append(h);\n}\n else {\nh=tmp.charAt(i);\n}\n}\nif ((len % 2) != 0) {\nsb.append((char)((h * 30) + 29));\n}\nreturn submode;\n}\n",
        "text": " Encode parts of the message using Text Compaction as described in ISO/IEC 15438:2001(E), chapter 4.4.2.",
        "id": 64
    },
    {
        "code": "public static boolean isValidNCName(String ncName){\n  if (ncName.length() == 0)   return false;\n  char ch=ncName.charAt(0);\n  if (isNCNameStart(ch) == false)   return false;\n  for (int i=1; i < ncName.length(); i++) {\n    ch=ncName.charAt(i);\n    if (isNCName(ch) == false) {\n      return false;\n    }\n  }\n  return true;\n}\n",
        "text": " Check to see if a string is a valid NCName according to [4] from the XML Namespaces 1.0 Recommendation",
        "id": 65
    },
    {
        "code": "public RepeatedFieldBuilder<MType,BType,IType> addMessage(MType message){\n  if (message == null) {\n    throw new NullPointerException();\n  }\n  ensureMutableMessageList();\n  messages.add(message);\n  if (builders != null) {\n    builders.add(null);\n  }\n  onChanged();\n  incrementModCounts();\n  return this;\n}\n",
        "text": " Appends the specified element to the end of this list.",
        "id": 66
    },
    {
        "code": "protected void prepareDataSet(){\n  dataSet1=Arrays.asList(new String[]{\"a\",\"b\",\"c\"});\n  dataSet2=Arrays.asList(new String[]{\"d\",\"e\",\"f\"});\n  dataSet3=Arrays.asList(new String[]{\"b\",\"c\",\"a\",\"d\"});\n}\n",
        "text": " prepare the dataset required for running test cases",
        "id": 67
    },
    {
        "code": "private ServiceRegistrar[] buildServiceRegistrar(){\n  int k=0;\n  ServiceRegistrar[] proxys=new ServiceRegistrar[proxyRegSet.size()];\n  Iterator iter=proxyRegSet.iterator();\n  while (iter.hasNext()) {\n    ProxyReg reg=(ProxyReg)iter.next();\n    proxys[k++]=reg.proxy;\n  }\n  return proxys;\n}\n",
        "text": " Returns array of ServiceRegistrar created from the proxyRegSet",
        "id": 68
    },
    {
        "code": "private static boolean checkValue(String val) throws MalformedObjectNameException {\n  if (val == null)   throw new NullPointerException(\"Invalid value (null)\");\n  final int len=val.length();\n  if (len == 0)   return false;\n  final char[] s=val.toCharArray();\n  final int[] result=parseValue(s,0);\n  final int endValue=result[0];\n  final boolean value_pattern=result[1] == 1;\n  if (endValue < len)   throw new MalformedObjectNameException(\"Invalid character in value: `\" + s[endValue] + \"'\");\n  return value_pattern;\n}\n",
        "text": " Check if the supplied value is a valid value.",
        "id": 69
    },
    {
        "code": "protected void recoverPrimary(Set excludedServers){\n  if (pool.getPoolOrCacheCancelInProgress() != null) {\n    return;\n  }\n  final boolean isDebugEnabled=logger.isDebugEnabled();\n  if (queueConnections.getPrimary() != null) {\n    if (isDebugEnabled) {\n      logger.debug(\"Primary recovery not needed\");\n    }\n    return;\n  }\n  if (isDebugEnabled) {\n    logger.debug(\"SubscriptionManager redundancy satisfier - primary endpoint has been lost. Attempting to recover\");\n  }\n  if (printRecoveringPrimary) {\n    logger.info(LocalizedMessage.create(LocalizedStrings.QueueManagerImpl_SUBSCRIPTION_MANAGER_REDUNDANCY_SATISFIER_PRIMARY_ENDPOINT_HAS_BEEN_LOST_ATTEMPTIMG_TO_RECOVER));\n    printRecoveringPrimary=false;\n  }\n  QueueConnectionImpl newPrimary=null;\n  while (newPrimary == null && pool.getPoolOrCacheCancelInProgress() == null) {\n    List backups=queueConnections.getBackups();\n    newPrimary=promoteBackupToPrimary(backups);\n    if (newPrimary == null) {\n      break;\n    }\n    if (!addToConnectionList(newPrimary,true)) {\nsynchronized (lock) {\n        queueConnections=queueConnections.removeConnection(newPrimary);\n      }\n      newPrimary=null;\n    }\n  }\n  if (newPrimary != null) {\n    if (isDebugEnabled) {\n      logger.debug(\"SubscriptionManager redundancy satisfier - Switched backup server to primary: {}\",newPrimary.getEndpoint());\n    }\n    if (PoolImpl.AFTER_PRIMARY_RECOVERED_CALLBACK_FLAG) {\n      ClientServerObserver bo=ClientServerObserverHolder.getInstance();\n      bo.afterPrimaryRecovered(newPrimary.getServer());\n    }\n    cqsConnected();\n    printPrimaryNotFoundError=true;\n    printRecoveringPrimary=true;\n    return;\n  }\n  while (newPrimary == null) {\n    newPrimary=createNewPrimary(excludedServers);\n    if (newPrimary == null) {\n      break;\n    }\n    if (!addToConnectionList(newPrimary,true)) {\n      excludedServers.add(newPrimary.getServer());\n      newPrimary=null;\n    }\n    if (newPrimary != null) {\n      if (isDebugEnabled) {\n        logger.debug(\"SubscriptionManager redundancy satisfier - Non backup server was made primary. Recovering interest {}\",newPrimary.getEndpoint());\n      }\n      if (!recoverInterest(newPrimary,true)) {\n        excludedServers.add(newPrimary.getServer());\n        newPrimary=null;\n      }\n      cqsConnected();\n    }\n    if (newPrimary != null && PoolImpl.AFTER_PRIMARY_RECOVERED_CALLBACK_FLAG) {\n      ClientServerObserver bo=ClientServerObserverHolder.getInstance();\n      bo.afterPrimaryRecovered(newPrimary.getServer());\n    }\n    printPrimaryNotFoundError=true;\n    printRecoveringPrimary=true;\n    return;\n  }\n  cqsDisconnected();\n  if (isDebugEnabled) {\n    logger.debug(\"SubscriptionManager redundancy satisfier - Could not recover a new primary\");\n  }\nsynchronized (lock) {\n    queueConnections=queueConnections.setPrimaryDiscoveryFailed(null);\n    lock.notifyAll();\n  }\n}\n",
        "text": " Find a new primary, adding any failed servers we encounter to the excluded servers list First we try to make a backup server the primary, but if run out of backup servers we will try to find a new server.",
        "id": 70
    },
    {
        "code": "private synchronized void rebuildJournal() throws IOException {\n  if (journalWriter != null) {\n    journalWriter.close();\n  }\n  Writer writer=new BufferedWriter(new FileWriter(journalFileTmp),IO_BUFFER_SIZE);\n  writer.write(MAGIC);\n  writer.write(\"\\n\");\n  writer.write(VERSION_1);\n  writer.write(\"\\n\");\n  writer.write(Integer.toString(appVersion));\n  writer.write(\"\\n\");\n  writer.write(Integer.toString(valueCount));\n  writer.write(\"\\n\");\n  writer.write(\"\\n\");\n  for (  Entry entry : lruEntries.values()) {\n    if (entry.currentEditor != null) {\n      writer.write(DIRTY + ' ' + entry.key+ '\\n');\n    }\n else {\n      writer.write(CLEAN + ' ' + entry.key+ entry.getLengths()+ '\\n');\n    }\n  }\n  writer.close();\n  journalFileTmp.renameTo(journalFile);\n  journalWriter=new BufferedWriter(new FileWriter(journalFile,true),IO_BUFFER_SIZE);\n}\n",
        "text": " Creates a new journal that omits redundant information. This replaces the current journal if it exists.",
        "id": 71
    },
    {
        "code": "public void remove() throws RecurrenceInfoException {\n  List<RecurrenceRule> rulesList=new ArrayList<RecurrenceRule>();\n  rulesList.addAll(rRulesList);\n  rulesList.addAll(eRulesList);\n  try {\n    for (    RecurrenceRule rule : rulesList)     rule.remove();\n    info.remove();\n  }\n catch (  RecurrenceRuleException rre) {\n    throw new RecurrenceInfoException(rre.getMessage(),rre);\n  }\ncatch (  GenericEntityException gee) {\n    throw new RecurrenceInfoException(gee.getMessage(),gee);\n  }\n}\n",
        "text": " Removes the recurrence from persistant store. ",
        "id": 72
    },
    {
        "code": "public void addNodesInDocOrder(DTMIterator iterator,XPathContext support){\n  if (!m_mutable)   throw new RuntimeException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NODESETDTM_NOT_MUTABLE,null));\n  int node;\n  while (DTM.NULL != (node=iterator.nextNode())) {\n    addNodeInDocOrder(node,support);\n  }\n}\n",
        "text": " Copy NodeList members into this nodelist, adding in document order.  If a node is null, don't add it.",
        "id": 73
    },
    {
        "code": "protected boolean needToRefetchData(){\n  long now=System.currentTimeMillis();\n  long last=lastDataFetchTime;\n  if ((last + fetchIntervalMillis) < now) {\n    lastDataFetchTime=now;\n    return true;\n  }\n  return false;\n}\n",
        "text": " Fetches data if it hasn't been fetched in a while.",
        "id": 74
    },
    {
        "code": "@Override public DocumentType createDocumentType(String qualifiedName,String publicID,String systemID){\n  checkQName(qualifiedName);\n  return new DocumentTypeImpl(null,qualifiedName,publicID,systemID);\n}\n",
        "text": " Introduced in DOM Level 2.     Creates an empty DocumentType node.",
        "id": 75
    },
    {
        "code": "public void handleRequest(RequestContext rc) throws CLIException {\n  super.handleRequest(rc);\n  ldapLogin();\n  SSOToken adminSSOToken=getAdminSSOToken();\n  IOutput outputWriter=getOutputWriter();\n  String realm=getStringOptionValue(IArgument.REALM_NAME);\n  String patternType=getStringOptionValue(IArgument.AGENT_TYPE);\n  String filter=getStringOptionValue(IArgument.FILTER);\n  if (patternType == null) {\n    patternType=\"\";\n  }\n  if ((filter == null) || (filter.length() == 0)) {\n    filter=\"*\";\n  }\n  String[] params={realm,patternType,filter};\n  writeLog(LogWriter.LOG_ACCESS,Level.INFO,\"ATTEMPT_LIST_AGENTS\",params);\n  try {\n    AMIdentityRepository amir=new AMIdentityRepository(adminSSOToken,realm);\n    IdSearchResults isr=amir.searchIdentities(IdType.AGENTONLY,filter,new IdSearchControl());\n    Set results=isr.getSearchResults();\n    if ((results != null) && !results.isEmpty()) {\n      for (Iterator i=results.iterator(); i.hasNext(); ) {\n        AMIdentity amid=(AMIdentity)i.next();\n        if (!matchType(amid,patternType)) {\n          i.remove();\n        }\n      }\n    }\n    if ((results != null) && !results.isEmpty()) {\n      for (Iterator i=results.iterator(); i.hasNext(); ) {\n        AMIdentity amid=(AMIdentity)i.next();\n        Object[] args={amid.getName(),amid.getUniversalId()};\n        outputWriter.printlnMessage(MessageFormat.format(getResourceString(\"format-search-agent-results\"),args));\n      }\n    }\n else {\n      outputWriter.printlnMessage(getResourceString(\"search-agent-no-entries\"));\n    }\n    writeLog(LogWriter.LOG_ACCESS,Level.INFO,\"SUCCEED_LIST_AGENTS\",params);\n  }\n catch (  IdRepoException e) {\n    String[] args={realm,patternType,filter,e.getMessage()};\n    debugError(\"ListAgents.handleRequest\",e);\n    writeLog(LogWriter.LOG_ERROR,Level.INFO,\"FAILED_LIST_AGENTS\",args);\n    throw new CLIException(e,ExitCodes.REQUEST_CANNOT_BE_PROCESSED);\n  }\ncatch (  SSOException e) {\n    String[] args={realm,patternType,filter,e.getMessage()};\n    debugError(\"ListAgents.handleRequest\",e);\n    writeLog(LogWriter.LOG_ERROR,Level.INFO,\"FAILED_LIST_AGENTS\",args);\n    throw new CLIException(e,ExitCodes.REQUEST_CANNOT_BE_PROCESSED);\n  }\n}\n",
        "text": " Services a Commandline Request.",
        "id": 76
    },
    {
        "code": "public byte[] toBytes(){\n  try {\n    ByteArrayOutputStream out=new ByteArrayOutputStream();\n    _field.store(out,null);\n    return out.toByteArray();\n  }\n catch (  IOException e) {\n    throw new IllegalStateException(e);\n  }\n}\n",
        "text": " Serializes this nested object into byte[]",
        "id": 77
    },
    {
        "code": "@SuppressWarnings(\"unchecked\") public static <E extends Enum<? extends Style.HasCssName>>E fromStyleName(final String styleName,final Class<E> enumClass,final E defaultValue){\n  if (styleName == null || enumClass == null) {\n    return defaultValue;\n  }\n  for (  final Enum<? extends Style.HasCssName> constant : enumClass.getEnumConstants()) {\n    final Style.HasCssName anEnum=(Style.HasCssName)constant;\n    final String cssClass=anEnum.getCssName();\n    if (cssClass != null && StyleHelper.containsStyle(styleName,cssClass)) {\n      return (E)anEnum;\n    }\n  }\n  return defaultValue;\n}\n",
        "text": " Returns first enum constant found in at space-separated list of style names.",
        "id": 78
    },
    {
        "code": "@HLEUnimplemented @HLEFunction(nid=0x3C37A7A6,version=150,checkInsideInterrupt=true) public int sceMpegNextAvcRpAu(@CheckArgument(\"checkMpegHandle\") int mpeg,int streamUid){\n  if (!streamMap.containsKey(streamUid)) {\n    log.warn(String.format(\"sceMpegNextAvcRpAu bad stream 0x%X\",streamUid));\n    return -1;\n  }\n  int result=hleMpegGetAvcAu(null);\n  if (result != 0) {\n    if (log.isDebugEnabled()) {\n      log.debug(String.format(\"sceMpegNextAvcRpAu returning 0x%08X\",result));\n    }\n    return result;\n  }\n  videoFrameCount++;\n  startedMpeg=true;\n  return 0;\n}\n",
        "text": " sceMpegNextAvcRpAu - skip one video frame",
        "id": 79
    },
    {
        "code": "private Map<URI,ExportMask> createExportMaskMap(Set<URI> placedMasks){\n  Map<URI,ExportMask> exportMaskMap=new HashMap<>();\n  Iterator<ExportMask> exportMaskIterator=dbClient.queryIterativeObjects(ExportMask.class,placedMasks,true);\n  while (exportMaskIterator.hasNext()) {\n    ExportMask exportMask=exportMaskIterator.next();\n    exportMaskMap.put(exportMask.getId(),exportMask);\n  }\n  return exportMaskMap;\n}\n",
        "text": " Given a set of ExportMask URIs, return a map of ExportMask URI to ExportMask object",
        "id": 80
    },
    {
        "code": "public ImmutableArray2<K> insert(int index,K obj){\n  int len=length + 1;\n  int newLen=len;\n  boolean extendable;\n  if (index == len - 1) {\n    AtomicBoolean x=canExtend;\n    if (x != null) {\n      canExtend=null;\n      if (array.length > index && x.getAndSet(false)) {\n        array[index]=obj;\n        return new ImmutableArray2<K>(array,len,true);\n      }\n    }\n    extendable=true;\n    newLen=len + 4;\n  }\n else {\n    extendable=false;\n  }\n  @SuppressWarnings(\"unchecked\") K[] a2=(K[])new Object[newLen];\n  DataUtils.copyWithGap(array,a2,length,index);\n  a2[index]=obj;\n  return new ImmutableArray2<K>(a2,len,extendable);\n}\n",
        "text": " Insert an entry at this index.",
        "id": 81
    },
    {
        "code": "public void writeNoScale(Image c,Component i){\n  if (page == null) {\n    newpage();\n  }\n  int x=x0 + width - (c.getWidth(null) + charwidth);\n  int y=y0 + (linenum * lineheight) + lineascent;\n  if (page != null && pagenum >= prFirst) {\n    page.drawImage(c,x,y,c.getWidth(null),c.getHeight(null),null);\n  }\n}\n",
        "text": " Write a graphic to the printout.   This was not in the original class, but was added afterwards by Kevin Dickerson. it is a copy of the write, but without the scaling.   The image is positioned on the right side of the paper, at the current height.",
        "id": 82
    },
    {
        "code": "public void putDocumentInCache(int n,Source source){\n  int cachedNode=getNode(source);\n  if (DTM.NULL != cachedNode) {\n    if (!(cachedNode == n))     throw new RuntimeException(\"Programmer's Error!  \" + \"putDocumentInCache found reparse of doc: \" + source.getSystemId());\n    return;\n  }\n  if (null != source.getSystemId()) {\n    m_sourceTree.addElement(new SourceTree(n,source.getSystemId()));\n  }\n}\n",
        "text": " Put the source tree root node in the document cache. TODO: This function needs to be a LOT more sophisticated.",
        "id": 83
    },
    {
        "code": "private void updateProgress(String progressLabel,int progress){\n  if (myHost != null && ((progress != previousProgress) || (!progressLabel.equals(previousProgressLabel)))) {\n    myHost.updateProgress(progressLabel,progress);\n  }\n  previousProgress=progress;\n  previousProgressLabel=progressLabel;\n}\n",
        "text": " Used to communicate a progress update between a plugin tool and the main Whitebox user interface.",
        "id": 84
    },
    {
        "code": "public static void copy(InputStream is,Resource out,boolean closeIS) throws IOException {\n  OutputStream os=null;\n  try {\n    os=toBufferedOutputStream(out.getOutputStream());\n  }\n catch (  IOException ioe) {\n    IOUtil.closeEL(os);\n    throw ioe;\n  }\n  copy(is,os,closeIS,true);\n}\n",
        "text": " copy a input resource to a output resource",
        "id": 85
    },
    {
        "code": "public String fadeAudio(String path,String type,double fadeInLength,double stopTime,double fadeOutLength) throws IOException {\n  final List<String> curves=Arrays.asList(new String[]{\"q\",\"h\",\"t\",\"l\",\"p\"});\n  if (!curves.contains(type)) {\n    throw new RuntimeException(\"fadeAudio: passed invalid type: \" + type);\n  }\n  File file=new File(path);\n  String outFile=file.getCanonicalPath() + \"_faded.wav\";\n  ArrayList<String> cmd=new ArrayList<String>();\n  cmd.add(soxBin);\n  cmd.add(path);\n  cmd.add(outFile);\n  cmd.add(\"fade\");\n  cmd.add(type);\n  cmd.add(fadeInLength + \"\");\n  if (stopTime != -1)   cmd.add(stopTime + \"\");\n  if (fadeOutLength != -1)   cmd.add(fadeOutLength + \"\");\n  try {\n    int rc=execSox(cmd,callback);\n    if (rc != 0) {\n      outFile=null;\n    }\n  }\n catch (  IOException e) {\n    e.printStackTrace();\n  }\ncatch (  InterruptedException e) {\n    e.printStackTrace();\n  }\n  return outFile;\n}\n",
        "text": " Fade audio file sox   outFile fade        ",
        "id": 86
    },
    {
        "code": "@Override public void draw(Canvas canvas){\n  super.draw(canvas);\n  if (mEdgeGlowTop != null) {\n    final int scrollX=getScrollX();\n    if (!mEdgeGlowTop.isFinished()) {\n      final int restoreCount=canvas.save();\n      final int topPadding=mListPadding.top + mGlowPaddingTop;\n      final int bottomPadding=mListPadding.bottom + mGlowPaddingBottom;\n      final int height=getHeight() - topPadding - bottomPadding;\n      int edgeX=Math.min(0,scrollX + mFirstPositionDistanceGuess);\n      canvas.rotate(-90);\n      canvas.translate(-getHeight() + topPadding,edgeX);\n      mEdgeGlowTop.setSize(height,height);\n      if (mEdgeGlowTop.draw(canvas)) {\n        invalidate();\n      }\n      canvas.restoreToCount(restoreCount);\n    }\n    if (!mEdgeGlowBottom.isFinished()) {\n      final int restoreCount=canvas.save();\n      final int topPadding=mListPadding.left + mGlowPaddingTop;\n      final int bottomPadding=mListPadding.right + mGlowPaddingBottom;\n      final int height=getHeight() - topPadding - bottomPadding;\n      final int width=getWidth();\n      int edgeX=Math.max(width,scrollX + mLastPositionDistanceGuess);\n      canvas.rotate(90);\n      canvas.translate(-topPadding,-edgeX);\n      mEdgeGlowBottom.setSize(height,height);\n      if (mEdgeGlowBottom.draw(canvas)) {\n        invalidate();\n      }\n      canvas.restoreToCount(restoreCount);\n    }\n  }\n}\n",
        "text": " TODO: to be implemented",
        "id": 87
    },
    {
        "code": "public static ClassProperties loadProperties(Class[] cls,Properties properties,boolean inherit){\n  ClassProperties cp=new ClassProperties(properties);\n  for (  Class c : cls) {\n    cp.load(c,inherit);\n  }\n  return cp;\n}\n",
        "text": " For all the classes, loads all properties from each Class annotations for the given platform.",
        "id": 88
    },
    {
        "code": "public void testCase20(){\n  byte bBytes[]={1,2,3,4,5,6,7};\n  byte rBytes[]={1,2,3,4,5,6,7};\n  int bSign=1;\n  BigInteger aNumber=BigInteger.ZERO;\n  BigInteger bNumber=new BigInteger(bSign,bBytes);\n  BigInteger result=aNumber.add(bNumber);\n  byte resBytes[]=new byte[rBytes.length];\n  resBytes=result.toByteArray();\n  for (int i=0; i < resBytes.length; i++) {\n    assertTrue(resBytes[i] == rBytes[i]);\n  }\n  assertEquals(\"incorrect sign\",1,result.signum());\n}\n",
        "text": " Add a number to zero",
        "id": 89
    },
    {
        "code": "private static void fixGPSTimeStamp(XMPNode exifSchema) throws XMPException {\n  XMPNode gpsDateTime=XMPNodeUtils.findChildNode(exifSchema,\"exif:GPSTimeStamp\",false);\n  if (gpsDateTime == null) {\n    return;\n  }\n  try {\n    XMPDateTime binGPSStamp;\n    XMPDateTime binOtherDate;\n    binGPSStamp=XMPUtils.convertToDate(gpsDateTime.getValue());\n    if (binGPSStamp.getYear() != 0 || binGPSStamp.getMonth() != 0 || binGPSStamp.getDay() != 0) {\n      return;\n    }\n    XMPNode otherDate=XMPNodeUtils.findChildNode(exifSchema,\"exif:DateTimeOriginal\",false);\n    if (otherDate == null) {\n      otherDate=XMPNodeUtils.findChildNode(exifSchema,\"exif:DateTimeDigitized\",false);\n    }\n    binOtherDate=XMPUtils.convertToDate(otherDate.getValue());\n    Calendar cal=binGPSStamp.getCalendar();\n    cal.set(Calendar.YEAR,binOtherDate.getYear());\n    cal.set(Calendar.MONTH,binOtherDate.getMonth());\n    cal.set(Calendar.DAY_OF_MONTH,binOtherDate.getDay());\n    binGPSStamp=new XMPDateTimeImpl(cal);\n    gpsDateTime.setValue(XMPUtils.convertFromDate(binGPSStamp));\n  }\n catch (  XMPException e) {\n    return;\n  }\n}\n",
        "text": " Fixes the GPS Timestamp in EXIF.",
        "id": 90
    },
    {
        "code": "protected boolean cellConsumesEventType(Cell<?> cell,String eventType){\n  Set<String> consumedEvents=cell.getConsumedEvents();\n  return consumedEvents != null && consumedEvents.contains(eventType);\n}\n",
        "text": " Check if a cell consumes the specified event type.",
        "id": 91
    },
    {
        "code": "public int read() throws IOException {\n  int b0=fInputStream.read();\n  if (b0 > 0x80) {\n    throw new IOException(Localizer.getMessage(\"jsp.error.xml.invalidASCII\",Integer.toString(b0)));\n  }\n  return b0;\n}\n",
        "text": " Read a single character.  This method will block until a character is available, an I/O error occurs, or the end of the stream is reached.   Subclasses that intend to support efficient single-character input should override this method.",
        "id": 92
    },
    {
        "code": "protected void create_y_axis(int i){\n  Log.e(\"index vlaue\",i + \"\");\n  float ver_height=((graphheight / label_size) * i) + border;\n  if (i == largest_value_set.size() - 1)   canvas.drawLine(horstart,ver_height,width - (border),ver_height,paint);\n else   canvas.drawLine(horstart,ver_height,border,ver_height,paint);\n  paint.setColor(Color.BLACK);\n  int Y_labels=(int)size - 1 - i;\n  String y_labels=String.format(\"%.1f\",Y_labels * y_axis_ratio);\n  paint.setTextAlign(Paint.Align.RIGHT);\n  canvas.drawText(y_labels,horstart - 15,ver_height - 10,paint);\n  paint.setTextAlign(Paint.Align.LEFT);\n}\n",
        "text": " This function is used to plot the y axis and its breakdown with value. Uses drawLine() method to create the y axis and lines to show breakdown of y axis and drawText() method to plot labels related with breakdowns",
        "id": 93
    },
    {
        "code": "public long max(){\n  return deltaMax.get();\n}\n",
        "text": " Get running-maximum time-delta, in nanoseconds.",
        "id": 94
    },
    {
        "code": "public void print(File file) throws IOException {\n  checkExec();\n  SecurityManager sm=System.getSecurityManager();\n  if (sm != null) {\n    sm.checkPrintJobAccess();\n  }\n  checkActionSupport(Action.PRINT);\n  checkFileValidation(file);\n  peer.print(file);\n}\n",
        "text": " Prints a file with the native desktop printing facility, using the associated application's print command.",
        "id": 95
    },
    {
        "code": "public void extend(RuleGrounding other){\n  if (other.isFailed()) {\n    groundings.clear();\n    return;\n  }\n  extend(other.getAlternatives());\n}\n",
        "text": " Extends the existing groundings with the alternative groundings",
        "id": 96
    },
    {
        "code": "@Override public String expect(Pattern pattern){\n  final String token=read(pattern);\n  if (token == null) {\n    throw new ParserException(\"Expected pattern '\" + pattern.pattern() + \"' was not encountered in document: \"+ document);\n  }\n  return token;\n}\n",
        "text": " This will attempt to read string matching the given pattern from the document at the current point indicated by the cursor. If failed to do so, the method will be expected to throw an exception or take corrective measures.",
        "id": 97
    },
    {
        "code": "public void testGetTableTypesOrder() throws Exception {\n  DatabaseMetaData dmd=con.getMetaData();\n  ResultSet rs=dmd.getTableTypes();\n  String previousType=\"\";\n  while (rs.next()) {\n    String type=rs.getString(1);\n    assertTrue(type.compareTo(previousType) >= 0);\n    previousType=type;\n  }\n  rs.close();\n}\n",
        "text": " Test for bug [974036] Bug in 0.8rc1 DatabaseMetaData method getTableTypes()",
        "id": 98
    },
    {
        "code": "private FileChannel updateCache(String filePath){\n  FileChannel fileChannel=fileNameAndStreamCache.get(filePath);\n  try {\n    if (null == fileChannel) {\n      FileInputStream stream=new FileInputStream(filePath);\n      fileChannel=stream.getChannel();\n      fileNameAndStreamCache.put(filePath,fileChannel);\n    }\n  }\n catch (  IOException e) {\n    LOGGER.error(e,e.getMessage());\n  }\n  return fileChannel;\n}\n",
        "text": " This method will be used to check whether stream is already present in cache or not for filepath if not present then create it and then add to cache, other wise get from cache",
        "id": 99
    },
    {
        "code": "public void removeSwipeListener(SwipeListener listener){\n  if (mListeners == null) {\n    return;\n  }\n  mListeners.remove(listener);\n}\n",
        "text": " Removes a listener from the set of listeners",
        "id": 100
    }
]