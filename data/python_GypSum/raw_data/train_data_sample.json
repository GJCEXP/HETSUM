[
    {
        "id": 0,
        "code": "def get_flashed_messages(with_categories=False, category_filter=[]):\n flashes = _request_ctx_stack.top.flashes\n if (flashes is None):\n  _request_ctx_stack.top.flashes = flashes = (session.pop('_flashes') if ('_flashes' in session) else [])\n if category_filter:\n  flashes = list(filter((lambda f: (f[0] in category_filter)), flashes))\n if (not with_categories):\n  return [x[1] for x in flashes]\n return flashes",
        "text": "pulls all flashed messages from the session and returns them ."
    },
    {
        "id": 1,
        "code": "def reorder_suite(suite, classes, reverse=False):\n class_count = len(classes)\n suite_class = type(suite)\n bins = [OrderedSet() for i in range((class_count + 1))]\n partition_suite_by_type(suite, classes, bins, reverse=reverse)\n reordered_suite = suite_class()\n for i in range((class_count + 1)):\n  reordered_suite.addTests(bins[i])\n return reordered_suite",
        "text": "reorders a test suite by test type ."
    },
    {
        "id": 2,
        "code": "def get_fun(fun):\n with _get_serv(ret=None, commit=True) as cur:\n  sql = 'SELECT s.id,s.jid, s.full_ret                 FROM salt_returns s                 JOIN ( SELECT MAX(`jid`) as jid                     from salt_returns GROUP BY fun, id) max                 ON s.jid = max.jid                 WHERE s.fun = %s                 '\n  cur.execute(sql, (fun,))\n  data = cur.fetchall()\n  ret = {}\n  if data:\n   for (minion, _, full_ret) in data:\n    ret[minion] = full_ret\n  return ret",
        "text": "return a dict of the last function called for all minions ."
    },
    {
        "id": 3,
        "code": "def import_module(name, required=True):\n try:\n  __import__(name, globals(), locals(), [])\n except ImportError:\n  if ((not required) and module_not_found()):\n   return None\n  raise\n return sys.modules[name]",
        "text": "import module by name ."
    },
    {
        "id": 4,
        "code": "def mapping(data_source, geom_name='geom', layer_key=0, multi_geom=False):\n if isinstance(data_source, str):\n  data_source = DataSource(data_source)\n elif isinstance(data_source, DataSource):\n  pass\n else:\n  raise TypeError('Data source parameter must be a string or a DataSource object.')\n _mapping = {}\n for field in data_source[layer_key].fields:\n  mfield = field.lower()\n  if (mfield[(-1):] == '_'):\n   mfield += 'field'\n  _mapping[mfield] = field\n gtype = data_source[layer_key].geom_type\n if multi_geom:\n  gtype.to_multi()\n _mapping[geom_name] = str(gtype).upper()\n return _mapping",
        "text": "given a datasource ."
    },
    {
        "id": 5,
        "code": "def patfilter(names, pat):\n if (pat not in _pat_cache):\n  _pat_cache[pat] = re.compile(_translate_pattern(pat))\n match = _pat_cache[pat].match\n return filter(match, names)",
        "text": "return the subset of the list names that match pat ."
    },
    {
        "id": 6,
        "code": "def test_interpolation(Chart):\n chart = Chart(interpolate='cubic')\n chart.add('1', [1, 3, 12, 3, 4])\n chart.add('2', [7, (-4), 10, None, 8, 3, 1])\n q = chart.render_pyquery()\n assert (len(q('.legend')) == 2)",
        "text": "test interpolation option ."
    },
    {
        "id": 7,
        "code": "def run_migrations_offline():\n engine_manager = EngineManager(config.get_required('DATABASE_HOSTS'), config.get_required('DATABASE_USERS'), include_disabled=True)\n engine = engine_manager.engines[shard_id]\n context.configure(engine=engine, url=engine.url)\n with context.begin_transaction():\n  context.run_migrations()",
        "text": "run migrations in offline mode ."
    },
    {
        "id": 8,
        "code": "def dict_to_numpy_array(d, mapping=None):\n try:\n  return dict_to_numpy_array2(d, mapping)\n except (AttributeError, TypeError):\n  return dict_to_numpy_array1(d, mapping)",
        "text": "convert a dictionary of dictionaries to a numpy array with optional mapping ."
    },
    {
        "id": 9,
        "code": "def _expand_probes(probes, defaults):\n expected_probes = {}\n for (probe_name, probe_test) in six.iteritems(probes):\n  if (probe_name not in expected_probes.keys()):\n   expected_probes[probe_name] = {}\n  probe_defaults = probe_test.pop('defaults', {})\n  for (test_name, test_details) in six.iteritems(probe_test):\n   test_defaults = test_details.pop('defaults', {})\n   expected_test_details = deepcopy(defaults)\n   expected_test_details.update(probe_defaults)\n   expected_test_details.update(test_defaults)\n   expected_test_details.update(test_details)\n   if (test_name not in expected_probes[probe_name].keys()):\n    expected_probes[probe_name][test_name] = expected_test_details\n return expected_probes",
        "text": "updates the probes dictionary with different levels of default values ."
    },
    {
        "id": 10,
        "code": "def test_records(test_data):\n ds = ChartDataSource.from_data(test_data.records_data)\n assert (len(ds.columns) == 2)\n assert (len(ds.index) == 4)",
        "text": "test creating chart data source from array of dicts ."
    },
    {
        "id": 11,
        "code": "def attach_total_voters_to_queryset(queryset, as_field='total_voters'):\n model = queryset.model\n type = apps.get_model('contenttypes', 'ContentType').objects.get_for_model(model)\n sql = 'SELECT coalesce(SUM(total_voters), 0) FROM (                 SELECT coalesce(votes_votes.count, 0) total_voters                   FROM votes_votes                  WHERE votes_votes.content_type_id = {type_id}                    AND votes_votes.object_id = {tbl}.id           ) as e'\n sql = sql.format(type_id=type.id, tbl=model._meta.db_table)\n qs = queryset.extra(select={as_field: sql})\n return qs",
        "text": "attach votes count to each object of the queryset ."
    },
    {
        "id": 12,
        "code": "def get_default_site(app_name='filebrowser'):\n resolver = get_resolver(get_urlconf())\n name = 'filebrowser'\n app_list = resolver.app_dict[app_name]\n if (name not in app_list):\n  name = app_list[0]\n return get_site_dict()[name]",
        "text": "returns the default site ."
    },
    {
        "id": 13,
        "code": "def _add_theming_locales():\n theme_locale_paths = settings.COMPREHENSIVE_THEME_LOCALE_PATHS\n for locale_path in theme_locale_paths:\n  settings.LOCALE_PATHS += (path(locale_path),)",
        "text": "add locale paths to settings for comprehensive theming ."
    },
    {
        "id": 14,
        "code": "def _load_plugins(config):\n paths = config['pluginpath'].get(confit.StrSeq(split=False))\n paths = map(util.normpath, paths)\n import beetsplug\n beetsplug.__path__ = (paths + beetsplug.__path__)\n sys.path += paths\n plugins.load_plugins(config['plugins'].as_str_seq())\n plugins.send('pluginload')\n return plugins",
        "text": "load the plugins specified in the configuration ."
    },
    {
        "id": 15,
        "code": "def serializers(opts):\n return LazyLoader(_module_dirs(opts, 'serializers'), opts, tag='serializers')",
        "text": "returns the serializers modules ."
    },
    {
        "id": 16,
        "code": "def rgb2short(r, g, b):\n dist = (lambda s, d: ((((s[0] - d[0]) ** 2) + ((s[1] - d[1]) ** 2)) + ((s[2] - d[2]) ** 2)))\n ary = [hex_to_rgb(hex) for hex in RGB2SHORT_DICT]\n m = min(ary, key=partial(dist, (r, g, b)))\n return RGB2SHORT_DICT[rgb_to_hex(m)]",
        "text": "rgb to short ."
    },
    {
        "id": 17,
        "code": "@deprecated(Version('Twisted', 15, 3, 0), replacement='twisted.web.template')\ndef output(func, *args, **kw):\n try:\n  return func(*args, **kw)\n except:\n  log.msg(('Error calling %r:' % (func,)))\n  log.err()\n  return PRE('An error occurred.')",
        "text": "output -> html string either return the result of a function  or a sparse htmlized error message and a message in the server log ."
    },
    {
        "id": 18,
        "code": "@register.filter(is_safe=True)\ndef pprint(value):\n try:\n  return pformat(value)\n except Exception as e:\n  return (u'Error in formatting: %s' % force_text(e, errors=u'replace'))",
        "text": "a wrapper around pprint ."
    },
    {
        "id": 19,
        "code": "def start_clientbrowser(config, args):\n logger.info('Start client mode (browser)')\n global client\n from glances.client_browser import GlancesClientBrowser\n client = GlancesClientBrowser(config=config, args=args)\n client.serve_forever()\n client.end()",
        "text": "start the browser client mode ."
    },
    {
        "id": 20,
        "code": "def unhex(s):\n bits = 0\n for c in s:\n  c = bytes((c,))\n  if ('0' <= c <= '9'):\n   i = ord('0')\n  elif ('a' <= c <= 'f'):\n   i = (ord('a') - 10)\n  elif ('A' <= c <= 'F'):\n   i = (ord('A') - 10)\n  else:\n   assert False, ('non-hex digit ' + repr(c))\n  bits = ((bits * 16) + (ord(c) - i))\n return bits",
        "text": "get the integer value of a hexadecimal number ."
    },
    {
        "id": 21,
        "code": "def walk(top, topdown=True, followlinks=False):\n names = os.listdir(top)\n (dirs, nondirs) = ([], [])\n for name in names:\n  if path.isdir(path.join(top, name)):\n   dirs.append(name)\n  else:\n   nondirs.append(name)\n if topdown:\n  (yield (top, dirs, nondirs))\n for name in dirs:\n  fullpath = path.join(top, name)\n  if (followlinks or (not path.islink(fullpath))):\n   for x in walk(fullpath, topdown, followlinks):\n    (yield x)\n if (not topdown):\n  (yield (top, dirs, nondirs))",
        "text": "backport of os ."
    },
    {
        "id": 22,
        "code": "def url_filename(url):\n match = upload_title_re.match(url)\n if match:\n  return match.group('filename')\n else:\n  return url",
        "text": "extract the filename if a url is an uploaded file ."
    },
    {
        "id": 23,
        "code": "@raises(ValueError)\ndef test_bootstrap_arglength():\n algo.bootstrap(np.arange(5), np.arange(10))",
        "text": "test that different length args raise valueerror ."
    },
    {
        "id": 24,
        "code": "def runwsgi(func):\n if os.environ.has_key('SERVER_SOFTWARE'):\n  os.environ['FCGI_FORCE_CGI'] = 'Y'\n if (os.environ.has_key('PHP_FCGI_CHILDREN') or os.environ.has_key('SERVER_SOFTWARE')):\n  return runfcgi(func)\n if ('scgi' in sys.argv):\n  return runscgi(func)\n return runsimple(func, listget(sys.argv, 1, 8080))",
        "text": "runs a wsgi-compatible function using fcgi ."
    },
    {
        "id": 25,
        "code": "def _offset_or_limit_clause(element, name=None, type_=None):\n if (element is None):\n  return None\n elif hasattr(element, '__clause_element__'):\n  return element.__clause_element__()\n elif isinstance(element, Visitable):\n  return element\n else:\n  value = util.asint(element)\n  return _OffsetLimitParam(name, value, type_=type_, unique=True)",
        "text": "convert the given value to an offset or limit clause ."
    },
    {
        "id": 26,
        "code": "def _get_cron_info():\n owner = 'root'\n if (__grains__['os'] == 'FreeBSD'):\n  group = 'wheel'\n  crontab_dir = '/var/spool/incron'\n elif (__grains__['os'] == 'OpenBSD'):\n  group = 'crontab'\n  crontab_dir = '/var/spool/incron'\n elif (__grains__.get('os_family') == 'Solaris'):\n  group = 'root'\n  crontab_dir = '/var/spool/incron'\n else:\n  group = 'root'\n  crontab_dir = '/var/spool/incron'\n return (owner, group, crontab_dir)",
        "text": "returns the proper group owner and path to the incron directory ."
    },
    {
        "id": 27,
        "code": "def hash_filehash(filename):\n md4 = hashlib.new(u'md4').copy\n def gen(f):\n  while True:\n   x = f.read(9728000)\n   if x:\n    (yield x)\n   else:\n    return\n def md4_hash(data):\n  m = md4()\n  m.update(data)\n  return m\n with open(filename, u'rb') as f:\n  a = gen(f)\n  hashes = [md4_hash(data).digest() for data in a]\n  if (len(hashes) == 1):\n   return to_hex(hashes[0])\n  else:\n   return md4_hash(reduce((lambda a, d: (a + d)), hashes, u'')).hexd",
        "text": "returns the ed2k hash of a given file ."
    },
    {
        "id": 28,
        "code": "def path_to_filesystem(root, *paths):\n paths = [sanitize_path(path).strip('/') for path in paths]\n safe_path = root\n for path in paths:\n  if (not path):\n   continue\n  for part in path.split('/'):\n   if (not is_safe_filesystem_path_component(part)):\n    raise UnsafePathError(part)\n   safe_path = os.path.join(safe_path, part)\n return safe_path",
        "text": "convert path to a local filesystem path relative to base_folder ."
    },
    {
        "id": 29,
        "code": "@receiver(user_logged_in)\ndef log_successful_login(sender, request, user, **kwargs):\n if settings.FEATURES['SQUELCH_PII_IN_LOGS']:\n  AUDIT_LOG.info(u'Login success - user.id: {0}'.format(user.id))\n else:\n  AUDIT_LOG.info(u'Login success - {0} ({1})'.format(user.username, user.email))",
        "text": "handler to log when logins have occurred successfully ."
    },
    {
        "id": 30,
        "code": "def create_connection(dest_pair, proxy_type=None, proxy_addr=None, proxy_port=None, proxy_username=None, proxy_password=None, timeout=None):\n sock = socksocket()\n if isinstance(timeout, (int, float)):\n  sock.settimeout(timeout)\n sock.set_proxy(proxy_type, proxy_addr, proxy_port, proxy_username, proxy_password)\n sock.connect(dest_pair)\n return sock",
        "text": "create_connection -> socket object like socket ."
    },
    {
        "id": 31,
        "code": "def _open(filepath, *args, **kwargs):\n if (not os.path.exists(filepath)):\n  filepath = os.path.join('..', filepath)\n return open(filepath, 'rb', *args, **kwargs)",
        "text": "wrapper function to search one dir above if a file does not exist ."
    },
    {
        "id": 32,
        "code": "def _expand_table(table):\n return np.repeat([[1, 1], [1, 0], [0, 1], [0, 0]], table.ravel(), axis=0)",
        "text": "expand a 2 by 2 contingency table to observations ."
    },
    {
        "id": 33,
        "code": "def open_pathname(pathname, verbose=0):\n try:\n  refno = Res.FSOpenResourceFile(pathname, u'', 1)\n except Res.Error as arg:\n  if (arg[0] != (-199)):\n   raise\n else:\n  return refno\n pathname = _decode(pathname, verbose=verbose)\n refno = Res.FSOpenResourceFile(pathname, u'', 1)",
        "text": "open a resource file given by pathname ."
    },
    {
        "id": 34,
        "code": "def get_preamble():\n latex_preamble = rcParams.get(u'pgf.preamble', u'')\n if (type(latex_preamble) == list):\n  latex_preamble = u' '.join(latex_preamble)\n return latex_preamble",
        "text": "get latex preamble from rc ."
    },
    {
        "id": 35,
        "code": "def arbitrary(module_name, func_name, args, kwargs={}):\n if module_name.startswith('calibre_plugins'):\n  from calibre.customize.ui import find_plugin\n  find_plugin\n module = importlib.import_module(module_name)\n func = getattr(module, func_name)\n return func(*args, **kwargs)",
        "text": "an entry point that allows arbitrary functions to be run in a parallel process ."
    },
    {
        "id": 36,
        "code": "def cert_from_key_info(key_info, ignore_age=False):\n res = []\n for x509_data in key_info.x509_data:\n  x509_certificate = x509_data.x509_certificate\n  cert = x509_certificate.text.strip()\n  cert = ' '.join(split_len(''.join([s.strip() for s in cert.split()]), 64))\n  if (ignore_age or active_cert(cert)):\n   res.append(cert)\n  else:\n   logger.info('Inactive cert')\n return res",
        "text": "get all x509 certs from a keyinfo instance ."
    },
    {
        "id": 37,
        "code": "def instance_group_update(context, group_uuid, values):\n return IMPL.instance_group_update(context, group_uuid, values)",
        "text": "update the attributes of an group ."
    },
    {
        "id": 38,
        "code": "def auth(request):\n import warnings\n warnings.warn('The context processor at `django.core.context_processors.auth` is deprecated; use the path `django.contrib.auth.context_processors.auth` instead.', PendingDeprecationWarning)\n from google.appengine._internal.django.contrib.auth.context_processors import auth as auth_context_processor\n return auth_context_processor(request)",
        "text": "deprecated ."
    },
    {
        "id": 39,
        "code": "def timeuntil(value, arg=None):\n from django.utils.timesince import timesince\n from datetime import datetime\n if (not value):\n  return ''\n if arg:\n  return timesince(arg, value)\n return timesince(datetime.now(), value)",
        "text": "formats a date as the time until that date (i ."
    },
    {
        "id": 40,
        "code": "def main():\n module = AnsibleModule(argument_spec={'table': {'required': True}, 'record': {'required': True}, 'col': {'required': True}, 'key': {'required': True}, 'value': {'required': True}, 'timeout': {'default': 5, 'type': 'int'}}, supports_check_mode=True)\n params_set(module)",
        "text": "entry point for ansible module ."
    },
    {
        "id": 41,
        "code": "def test_hashbang():\n entry = tokenize('#!this is a comment ')\n assert (entry == [])",
        "text": "ensure we can escape things ."
    },
    {
        "id": 42,
        "code": "def analyze_modules(project, task_handle=taskhandle.NullTaskHandle()):\n resources = project.get_python_files()\n job_set = task_handle.create_jobset('Analyzing Modules', len(resources))\n for resource in resources:\n  job_set.started_job(resource.path)\n  analyze_module(project, resource)\n  job_set.finished_job()",
        "text": "perform static object analysis on all python files in the project note that this might be really time consuming ."
    },
    {
        "id": 43,
        "code": "def addBeginXMLTag(attributes, depth, localName, output, text=''):\n depthStart = (' DCTB ' * depth)\n output.write(('%s<%s%s>%s ' % (depthStart, localName, getAttributesString(attributes), text)))",
        "text": "add the begin xml tag ."
    },
    {
        "id": 44,
        "code": "def exists(name):\n with settings(hide('running', 'stdout', 'warnings'), warn_only=True):\n  return run(('getent passwd %(name)s' % locals())).succeeded",
        "text": "check if a user exists ."
    },
    {
        "id": 45,
        "code": "def disassociate_api_key_stagekeys(apiKey, stagekeyslist, region=None, key=None, keyid=None, profile=None):\n try:\n  conn = _get_conn(region=region, key=key, keyid=keyid, profile=profile)\n  pvlist = [('/stages', stagekey) for stagekey in stagekeyslist]\n  response = _api_key_patch_remove(conn, apiKey, pvlist)\n  return {'disassociated': True}\n except ClientError as e:\n  return {'disassociated': False, 'error': salt.utils.boto3.get_error(e)}",
        "text": "disassociate the given stagekeyslist to the given apikey ."
    },
    {
        "id": 46,
        "code": "@then(u'we see database dropped')\ndef step_see_db_dropped(context):\n _expect_exact(context, u'DROP DATABASE', timeout=2)",
        "text": "wait to see drop database output ."
    },
    {
        "id": 47,
        "code": "@bdd.when(bdd.parsers.parse('I wait for the javascript message \"{message}\"'))\ndef javascript_message_when(quteproc, message):\n quteproc.wait_for_js(message)",
        "text": "make sure the given message was logged via javascript ."
    },
    {
        "id": 48,
        "code": "def create_mount_target(filesystemid, subnetid, ipaddress=None, securitygroups=None, keyid=None, key=None, profile=None, region=None, **kwargs):\n client = _get_conn(key=key, keyid=keyid, profile=profile, region=region)\n return client.create_mount_point(FileSystemId=filesystemid, SubnetId=subnetid, IpAddress=ipaddress, SecurityGroups=securitygroups)",
        "text": "creates a mount target for a file system ."
    },
    {
        "id": 49,
        "code": "def IsAutoGenerated(xml_str):\n try:\n  xml_root = ElementTree.fromstring(xml_str)\n  return ((xml_root.tag == 'datastore-indexes') and _BooleanAttribute(xml_root.attrib.get('autoGenerate', 'false')))\n except ElementTree.ParseError:\n  return False",
        "text": "test if the given datastore-indexes ."
    },
    {
        "id": 50,
        "code": "def jnp_zeros(n, nt):\n return jnyn_zeros(n, nt)[1]",
        "text": "compute zeros of integer-order bessel function derivative jn(x) ."
    },
    {
        "id": 51,
        "code": "def set_time(time):\n time_format = _get_date_time_format(time)\n dt_obj = datetime.strptime(time, time_format)\n cmd = 'systemsetup -settime {0}'.format(dt_obj.strftime('%H:%M:%S'))\n return salt.utils.mac_utils.execute_return_success(cmd)",
        "text": "sets the current time ."
    },
    {
        "id": 52,
        "code": "def getRectangularGrid(diameter, loopsComplex, maximumComplex, minimumComplex, zigzag):\n demiradius = (0.25 * diameter)\n xStart = (minimumComplex.real - demiradius.real)\n y = (minimumComplex.imag - demiradius.imag)\n gridPath = []\n rowIndex = 0\n while (y < maximumComplex.imag):\n  addGridRow(diameter, gridPath, loopsComplex, maximumComplex, rowIndex, xStart, y, zigzag)\n  y += diameter.imag\n  rowIndex += 1\n return gridPath",
        "text": "get rectangular grid ."
    },
    {
        "id": 53,
        "code": "def get_discount_modules():\n return load_module_instances('SHUUP_DISCOUNT_MODULES', 'discount_module')",
        "text": "get a list of configured discount module instances ."
    },
    {
        "id": 54,
        "code": "def test_sample_wrong_X():\n sm = SMOTEENN(random_state=RND_SEED)\n sm.fit(X, Y)\n assert_raises(RuntimeError, sm.sample, np.random.random((100, 40)), np.array((([0] * 50) + ([1] * 50))))",
        "text": "test either if an error is raised when x is different at fitting and sampling ."
    },
    {
        "id": 55,
        "code": "def initialize_log_data(ids_bcs_added_field):\n log_data = {}\n for curr_key in ids_bcs_added_field.keys():\n  base_key = ''\n  if curr_key[0]:\n   base_key += (curr_key[0] + ',')\n  if curr_key[1]:\n   base_key += (curr_key[1] + ',')\n  base_key += ids_bcs_added_field[curr_key]\n  log_data[base_key] = 0\n return log_data",
        "text": "initializes log data ."
    },
    {
        "id": 56,
        "code": "def is_sequence_of_strings(obj):\n if (not iterable(obj)):\n  return False\n if is_string_like(obj):\n  return False\n for o in obj:\n  if (not is_string_like(o)):\n   return False\n return True",
        "text": "returns true if *obj  is iterable and contains strings ."
    },
    {
        "id": 57,
        "code": "def capture_screenshot_for_step(step, when):\n if world.auto_capture_screenshots:\n  scenario_num = (step.scenario.feature.scenarios.index(step.scenario) + 1)\n  step_num = (step.scenario.steps.index(step) + 1)\n  step_func_name = step.defined_at.function.func_name\n  image_name = '{prefix:03d}__{num:03d}__{name}__{postfix}'.format(prefix=scenario_num, num=step_num, name=step_func_name, postfix=when)\n  world.capture_screenshot(image_name)",
        "text": "useful method for debugging acceptance tests that are run in vagrant ."
    },
    {
        "id": 58,
        "code": "def get_sw_login_version():\n return '-'.join(get_sw_version(strip_build_num=True).split('-')[1:(-2)])",
        "text": "return a shortened version string ."
    },
    {
        "id": 59,
        "code": "def run_vcs_tool(path, action):\n info = get_vcs_info(get_vcs_root(path))\n tools = info['actions'][action]\n for (tool, args) in tools:\n  if programs.find_program(tool):\n   programs.run_program(tool, args, cwd=path)\n   return\n else:\n  cmdnames = [name for (name, args) in tools]\n  raise ActionToolNotFound(info['name'], action, cmdnames)",
        "text": "if path is a valid vcs repository ."
    },
    {
        "id": 60,
        "code": "def highlighting(view, name, style, left, right):\n tag_settings = sublime.load_settings('bh_tag.sublime-settings')\n match_style = tag_settings.get('tag_style', {}).get(last_mode, None)\n if ((match_style is not None) and (style == match_style)):\n  tag_name = tag_settings.get('tag_name', {}).get(last_mode, '[\\\\w\\\\:\\\\.\\\\-]+')\n  if (left is not None):\n   region = view.find(tag_name, left.begin)\n   left = left.move(region.begin(), region.end())\n  if (right is not None):\n   region = view.find(tag_name, right.begin)\n   right = right.move(region.begin(), region.end())\n return (left, right)",
        "text": "highlight only the tag name ."
    },
    {
        "id": 61,
        "code": "def set_policy(table='filter', chain=None, policy=None, family='ipv4'):\n if (not chain):\n  return 'Error: Chain needs to be specified'\n if (not policy):\n  return 'Error: Policy needs to be specified'\n wait = ('--wait' if _has_option('--wait', family) else '')\n cmd = '{0} {1} -t {2} -P {3} {4}'.format(_iptables_cmd(family), wait, table, chain, policy)\n out = __salt__['cmd.run'](cmd)\n return out",
        "text": "set the current policy for the specified table/chain cli example: ."
    },
    {
        "id": 62,
        "code": "def uni_print(statement, out_file=None):\n if (out_file is None):\n  out_file = sys.stdout\n try:\n  out_file.write(statement)\n except UnicodeEncodeError:\n  new_encoding = getattr(out_file, 'encoding', 'ascii')\n  if (new_encoding is None):\n   new_encoding = 'ascii'\n  new_statement = statement.encode(new_encoding, 'replace').decode(new_encoding)\n  out_file.write(new_statement)\n out_file.flush()",
        "text": "this function is used to properly write unicode to a file ."
    },
    {
        "id": 63,
        "code": "def pretty_name(name):\n name = (name[0].upper() + name[1:])\n return name.replace('_', ' ')",
        "text": "converts first_name to first name ."
    },
    {
        "id": 64,
        "code": "def list_snapshots(domain=None):\n ret = dict()\n for vm_domain in _get_domain(iterable=True, *((domain and [domain]) or list())):\n  ret[vm_domain.name()] = ([_parse_snapshot_description(snap) for snap in vm_domain.listAllSnapshots()] or 'N/A')\n return ret",
        "text": "list available snapshots for certain vm or for all ."
    },
    {
        "id": 65,
        "code": "def to(location, code=falcon.HTTP_302):\n raise falcon.http_status.HTTPStatus(code, {'location': location})",
        "text": "redirects to the specified location using the provided http_code ."
    },
    {
        "id": 66,
        "code": "@pytest.fixture(scope=u'session')\ndef celery_config():\n return {}",
        "text": "redefine this fixture to configure the test celery app ."
    },
    {
        "id": 67,
        "code": "def partial_project(endog, exog):\n (x1, x2) = (endog, exog)\n params = np.linalg.pinv(x2).dot(x1)\n predicted = x2.dot(params)\n residual = (x1 - predicted)\n res = Bunch(params=params, fittedvalues=predicted, resid=residual)\n return res",
        "text": "helper function to get linear projection or partialling out of variables endog variables are projected on exog variables parameters endog : ndarray array of variables where the effect of exog is partialled out ."
    },
    {
        "id": 68,
        "code": "def update(directory, composer=None, php=None, runas=None, prefer_source=None, prefer_dist=None, no_scripts=None, no_plugins=None, optimize=None, no_dev=None, quiet=False, composer_home='/root'):\n result = _run_composer('update', directory=directory, extra_flags='--no-progress', composer=composer, php=php, runas=runas, prefer_source=prefer_source, prefer_dist=prefer_dist, no_scripts=no_scripts, no_plugins=no_plugins, optimize=optimize, no_dev=no_dev, quiet=quiet, composer_home=composer_home)\n return result",
        "text": "update composer dependencies for a directory ."
    },
    {
        "id": 69,
        "code": "def getPath(edges, pathIndexes, loop, z):\n path = []\n for pathIndexIndex in xrange(len(pathIndexes)):\n  pathIndex = pathIndexes[pathIndexIndex]\n  edge = edges[pathIndex]\n  carveIntersection = getCarveIntersectionFromEdge(edge, loop, z)\n  path.append(carveIntersection)\n return path",
        "text": "get the path from the edge intersections ."
    },
    {
        "id": 70,
        "code": "@blueprint.route('/<job_id>.json', methods=['GET'])\n@blueprint.route('/<job_id>', methods=['GET'])\ndef show(job_id):\n job = scheduler.get_job(job_id)\n if (job is None):\n  raise werkzeug.exceptions.NotFound('Job not found')\n related_jobs = scheduler.get_related_jobs(job)\n if request_wants_json():\n  return flask.jsonify(job.json_dict(True))\n elif isinstance(job, model_images.ImageClassificationModelJob):\n  return model_images.classification.views.show(job, related_jobs=related_jobs)\n elif isinstance(job, model_images.GenericImageModelJob):\n  return model_images.generic.views.show(job, related_jobs=related_jobs)\n else:\n  raise werkzeug.exceptions.BadRequest('Invalid job type')",
        "text": "show a modeljob returns json when requested: {id ."
    },
    {
        "id": 71,
        "code": "def test(condition, true, false):\n if condition:\n  return true\n else:\n  return false",
        "text": "implements the c expression: condition ? true : false required to correctly interpret plural forms ."
    },
    {
        "id": 72,
        "code": "def connect_to_region(region_name, **kw_params):\n for region in regions():\n  if (region.name == region_name):\n   return region.connect(**kw_params)\n return None",
        "text": "given a valid region name ."
    },
    {
        "id": 73,
        "code": "def ePut(Handle, IOType, Channel, Value, x1):\n if (os.name == 'nt'):\n  staticLib = ctypes.windll.LoadLibrary('labjackud')\n  pv = ctypes.c_double(Value)\n  ec = staticLib.ePut(Handle, IOType, Channel, pv, x1)\n  if (ec != 0):\n   raise LabJackException(ec)\n else:\n  raise LabJackException(0, 'Function only supported for Windows')",
        "text": "put one value to the labjack device eput is equivilent to an addrequest followed by a goone ."
    },
    {
        "id": 74,
        "code": "def _organize_states_for_delete(base_mapper, states, uowtransaction):\n states_to_delete = []\n for (state, dict_, mapper, connection) in _connections_for_states(base_mapper, uowtransaction, states):\n  mapper.dispatch.before_delete(mapper, connection, state)\n  states_to_delete.append((state, dict_, mapper, bool(state.key), connection))\n return states_to_delete",
        "text": "make an initial pass across a set of states for delete ."
    },
    {
        "id": 75,
        "code": "def local_binary_pattern(image, P, R, method='default'):\n assert_nD(image, 2)\n methods = {'default': ord('D'), 'ror': ord('R'), 'uniform': ord('U'), 'nri_uniform': ord('N'), 'var': ord('V')}\n image = np.ascontiguousarray(image, dtype=np.double)\n output = _local_binary_pattern(image, P, R, methods[method.lower()])\n return output",
        "text": "gray scale and rotation invariant lbp ."
    },
    {
        "id": 76,
        "code": "def handleNewest(qry):\n try:\n  getUserName()\n except:\n  return _skypeError()\n qry = qry.decode('utf8')\n try:\n  if ((':' in qry) and (qry.partition(':')[0] in map((lambda s: s[0]), _readFriends()))):\n   return _sendMessageWait(qry)\n  else:\n   return _findNewest()\n except EnvironmentError:\n  return PyFred('ch.xtin.skypingalfred.error', False).addItem('skypeupdate', 'skype update', 'No Skype Friends Found', 'Use skype update to cache friends!', True, 'update').toXML()\n except:\n  return PyFred.GenericError()",
        "text": "gets the newest 5 messages ."
    },
    {
        "id": 77,
        "code": "@validate('tree')\ndef valid_field_in_tree(arch):\n return all(((child.tag in ('field', 'button')) for child in arch.xpath('/tree/*')))",
        "text": "children of tree view must be field or button ."
    },
    {
        "id": 78,
        "code": "def get_load(jid):\n serv = _get_serv(ret=None)\n data = serv.get('load:{0}'.format(jid))\n if data:\n  return json.loads(data)\n return {}",
        "text": "return the load data that marks a specified jid ."
    },
    {
        "id": 79,
        "code": "def cr_uid_ids(method):\n method._api = 'cr_uid_ids'\n return method",
        "text": "decorate a traditional-style method that takes cr ."
    },
    {
        "id": 80,
        "code": "def quota_destroy_all_by_project(context, project_id):\n return IMPL.quota_destroy_all_by_project(context, project_id)",
        "text": "destroy all quotas associated with a given project ."
    },
    {
        "id": 81,
        "code": "def _default_selem(func):\n @functools.wraps(func)\n def func_out(image, selem=None, *args, **kwargs):\n  if (selem is None):\n   selem = ndi.generate_binary_structure(image.ndim, image.ndim)\n  return func(image, selem=selem, *args, **kwargs)\n return func_out",
        "text": "decorator to add a default structuring element to morphology functions ."
    },
    {
        "id": 82,
        "code": "def _get_date_time_format(dt_string):\n valid_formats = ['%I:%M:%S %p', '%I:%M %p', '%H:%M:%S', '%H:%M', '%Y-%m-%d', '%m-%d-%y', '%m-%d-%Y', '%m/%d/%y', '%m/%d/%Y', '%Y/%m/%d']\n for dt_format in valid_formats:\n  try:\n   datetime.strptime(dt_string, dt_format)\n   return dt_format\n  except ValueError:\n   continue\n return False",
        "text": "copied from win_system ."
    },
    {
        "id": 83,
        "code": "def issue_section(issue):\n labels = issue.get('labels', [])\n for label in labels:\n  if (not label['name'].startswith('type: ')):\n   continue\n  if (label['name'] in LOG_SECTION):\n   return LOG_SECTION[label['name']]\n  elif (label['name'] in IGNORE_ISSUE_TYPE):\n   return None\n  else:\n   logging.warn('unknown issue type: \"{}\" for: {}'.format(label['name'], issue_line(issue)))\n return None",
        "text": "returns the section heading for the issue ."
    },
    {
        "id": 84,
        "code": "@preserve_value(sys, 'dont_write_bytecode')\ndef _load_module_no_bytecode(filename, module_file, module_file_path, py_source_description):\n sys.dont_write_bytecode = 1\n new_module = imp.load_module(os.path.splitext(filename)[0].replace('-', '_'), module_file, module_file_path, py_source_description)\n return new_module",
        "text": "helper function to load a module while setting sys ."
    },
    {
        "id": 85,
        "code": "def rollback(using=None):\n get_connection(using).rollback()",
        "text": "rolls back a transaction ."
    },
    {
        "id": 86,
        "code": "def install():\n p = KQueueReactor()\n from twisted.internet.main import installReactor\n installReactor(p)",
        "text": "install the kqueue() reactor ."
    },
    {
        "id": 87,
        "code": "def make_path_result(r, t):\n rpath = ('/recipes/' + r)\n tpath = ('/tasks/' + t)\n return ((rpath + tpath) + '/results/')",
        "text": "converts task id into a beaker path to result file given a recipe id and a task id ."
    },
    {
        "id": 88,
        "code": "def populate_tables(db, prefix, tmp_prefix, bounds):\n bbox = ('ST_SetSRID(ST_MakeBox2D(ST_MakePoint(%.6f, %.6f), ST_MakePoint(%.6f, %.6f)), 900913)' % bounds)\n db.execute('BEGIN')\n for table in ('point', 'line', 'roads', 'polygon'):\n  db.execute(('DELETE FROM %(prefix)s_%(table)s WHERE ST_Intersects(way, %(bbox)s)' % locals()))\n  db.execute(('INSERT INTO %(prefix)s_%(table)s                       SELECT * FROM %(tmp_prefix)s_%(table)s                       WHERE ST_Intersects(way, %(bbox)s)' % locals()))\n db.execute('COMMIT')",
        "text": "move prepared osm data from temporary to permanent tables ."
    },
    {
        "id": 89,
        "code": "def round_if_near_integer(a, epsilon=0.0001):\n if (abs((a - round(a))) <= epsilon):\n  return round(a)\n else:\n  return a",
        "text": "round a to the nearest integer if that integer is within an epsilon of a ."
    },
    {
        "id": 90,
        "code": "@requires_sklearn\ndef test_gat_plot_nonsquared():\n gat = _get_data(test_times=dict(start=0.0))\n gat.plot()\n ax = gat.plot_diagonal()\n scores = ax.get_children()[1].get_lines()[2].get_ydata()\n assert_equals(len(scores), len(gat.estimators_))",
        "text": "test gat diagonal plot ."
    },
    {
        "id": 91,
        "code": "def make_msgid(idstring=None):\n timeval = time.time()\n utcdate = time.strftime(u'%Y%m%d%H%M%S', time.gmtime(timeval))\n try:\n  pid = os.getpid()\n except AttributeError:\n  pid = 1\n randint = random.randrange(100000)\n if (idstring is None):\n  idstring = u''\n else:\n  idstring = (u'.' + idstring)\n idhost = DNS_NAME\n msgid = (u'<%s.%s.%s%s@%s>' % (utcdate, pid, randint, idstring, idhost))\n return msgid",
        "text": "returns a string suitable for rfc 2822 compliant message-id ."
    },
    {
        "id": 92,
        "code": "def _add_keys_to_request(request_field_pb, key_pbs):\n for key_pb in key_pbs:\n  request_field_pb.add().CopyFrom(key_pb)",
        "text": "add protobuf keys to a request object ."
    },
    {
        "id": 93,
        "code": "def execute_on_completion(application, config, callback):\n def inner(environ, start_response):\n  try:\n   result = application(environ, start_response)\n  except:\n   callback(environ)\n   raise\n  return generate_close_and_callback(result, callback, environ)\n return inner",
        "text": "call callback once complete response is sent ."
    },
    {
        "id": 94,
        "code": "def initgroups(uid, gid):\n if (not pwd):\n  return\n username = pwd.getpwuid(uid)[0]\n if hasattr(os, u'initgroups'):\n  return os.initgroups(username, gid)\n groups = [gr.gr_gid for gr in grp.getgrall() if (username in gr.gr_mem)]\n setgroups(groups)",
        "text": "init process group permissions ."
    },
    {
        "id": 95,
        "code": "def _SetWsdlMethod(ns, wsdlName, inputMM):\n _wsdlMethodNSs.add(ns)\n curMM = _wsdlMethodMap.get((ns, wsdlName))\n if isinstance(inputMM, list):\n  if (curMM is None):\n   _wsdlMethodMap[(ns, wsdlName)] = inputMM\n   return inputMM\n  elif isinstance(curMM, list):\n   raise RuntimeError(('Duplicate wsdl method %s %s (new class %s vs existing %s)' % (ns, wsdlName, inputMM[0], curMM[0])))\n  else:\n   return curMM\n elif ((curMM is None) or isinstance(curMM, list)):\n  _wsdlMethodMap[(ns, wsdlName)] = inputMM\n  return inputMM\n else:\n  return curMM",
        "text": "set a wsdl method with wsdl namespace and wsdl name returns added method / existing method if  already in the map note: must be holding the _lazylock ."
    },
    {
        "id": 96,
        "code": "def escape_byte_string(s):\n s = _replace_specials(s)\n try:\n  return s.decode('ASCII')\n except UnicodeDecodeError:\n  pass\n if IS_PYTHON3:\n  s_new = bytearray()\n  (append, extend) = (s_new.append, s_new.extend)\n  for b in s:\n   if (b >= 128):\n    extend(('\\\\%3o' % b).encode('ASCII'))\n   else:\n    append(b)\n  return s_new.decode('ISO-8859-1')\n else:\n  l = []\n  append = l.append\n  for c in s:\n   o = ord(c)\n   if (o >= 128):\n    append(('\\\\%3o' % o))\n   else:\n    append(c)\n  return join_bytes(l).decode('ISO-8859-1')",
        "text": "escape a byte string so that it can be written into c code ."
    },
    {
        "id": 97,
        "code": "def require_finance_admin(func):\n def wrapped(request, course_id):\n  try:\n   course_key = CourseKey.from_string(course_id)\n  except InvalidKeyError:\n   log.error(u'Unable to find course with course key %s', course_id)\n   return HttpResponseNotFound()\n  access = auth.user_has_role(request.user, CourseFinanceAdminRole(course_key))\n  if access:\n   return func(request, course_id)\n  else:\n   return HttpResponseForbidden()\n return wrapped",
        "text": "decorator for checking finance administrator access before executing an http endpoint ."
    },
    {
        "id": 98,
        "code": "def contains(name, value):\n ret = {'name': name, 'result': False, 'comment': '', 'changes': {}}\n if (name not in __reg__):\n  ret['result'] = False\n  ret['comment'] = 'Value {0} not in register'.format(name)\n  return ret\n try:\n  if (value in __reg__[name]['val']):\n   ret['result'] = True\n except TypeError:\n  pass\n return ret",
        "text": "only succeed if the value in the given register location contains the given value usage: ."
    },
    {
        "id": 99,
        "code": "def debug(brule, file=None):\n if (not file):\n  from sys import stdout\n  file = stdout\n def write(brl, expr, result):\n  file.write(('Rule: %s ' % get_function_name(brl)))\n  file.write(('In: %s Out: %s  ' % (expr, result)))\n return onaction(brule, write)",
        "text": "print the input and output expressions at each rule application ."
    }
]